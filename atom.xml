<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yanchao0716.github.io</id>
    <title>yanchao&apos; blog</title>
    <updated>2020-02-27T13:54:49.513Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yanchao0716.github.io"/>
    <link rel="self" href="https://yanchao0716.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://yanchao0716.github.io/images/avatar.png</logo>
    <icon>https://yanchao0716.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, yanchao&apos; blog</rights>
    <entry>
        <title type="html"><![CDATA[Spring @Scheduled线程模型探究 - 源码追踪]]></title>
        <id>https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-yuan-ma-zhui-zong/</id>
        <link href="https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-yuan-ma-zhui-zong/">
        </link>
        <updated>2020-02-27T13:49:15.000Z</updated>
        <content type="html"><![CDATA[<p>接<a href="https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-fa-xian-wen-ti/">上一篇</a>我们来分析一下 @Scheduled 这个定时器的注解实现</p>
<p>首先我看下@Scheduled注解的定义</p>
<pre><code class="language-java">package org.springframework.scheduling.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(Schedules.class)
public @interface Scheduled {
	String CRON_DISABLED = &quot;-&quot;;
	String cron() default &quot;&quot;;
	String zone() default &quot;&quot;;
	long fixedDelay() default -1;
	String fixedDelayString() default &quot;&quot;;
	long fixedRate() default -1;
	String fixedRateString() default &quot;&quot;;
	long initialDelay() default -1;
	String initialDelayString() default &quot;&quot;;
}
</code></pre>
<p>注解的字段分别对cron表达式、fixedDelay、fixRate进行了支持，可以传入value</p>
<p>紧接着我们看下@Scheduled在哪里被用到，跟进去查看一下实现<br>
<img src="https://img-blog.csdnimg.cn/20200222151601696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>这里我们主要看ScheduledAnnotationBeanPostProcessor这个类，其他几个类我们稍后再说。<br>
<img src="https://img-blog.csdnimg.cn/20200222154351658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>ScheduledAnnotationBeanPostProcessor是spring BeanPostProcessor的实现，postProcessAfterInitialization(Object bean, String beanName)方法在Bean初始化之后执行。</p>
<ol>
<li>提取定时方法：抽取@Scheduled注解以及被注解的方法</li>
<li>处理定时方法：对定时方法进行注册委托给定时器，通过processScheduled()方法实现</li>
</ol>
<p>processScheduled方法提取了注解上的值，cron、fixedDelay、fixRate分别包装成不同的对象，通过registrar.scheduleCronTask方法注册到registrar中</p>
<pre><code class="language-java">protected void processScheduled(Scheduled scheduled, Method method, Object bean) {
		 	Runnable runnable = createRunnable(bean, method);
			Set&lt;ScheduledTask&gt; tasks = new LinkedHashSet&lt;&gt;(4);
			
			// 确定定时器初始延迟时间
			long initialDelay = scheduled.initialDelay();
			String initialDelayString = scheduled.initialDelayString();
			...
			initialDelay = parseDelayAsLong(initialDelayString);
			...

			// cron表达式实现
			String cron = scheduled.cron();
			...
			tasks.add(this.registrar.scheduleCronTask(new CronTask(runnable, new CronTrigger(cron, timeZone))));
			...

			// fixed delay实现
			long fixedDelay = scheduled.fixedDelay();
			...
			tasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay)));
			...

			// fixed rate实现
			long fixedRate = scheduled.fixedRate();
			...
			tasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay)));
			...
		}
	}
</code></pre>
<p>registrar是ScheduledTaskRegistrar类的实例，ScheduledTaskRegistrar类主要结构如下</p>
<pre><code class="language-java">public class ScheduledTaskRegistrar implements ScheduledTaskHolder, InitializingBean, DisposableBean {
	private TaskScheduler taskScheduler;
	private ScheduledExecutorService localExecutor;
	private List&lt;TriggerTask&gt; triggerTasks;
	private List&lt;CronTask&gt; cronTasks;
	private List&lt;IntervalTask&gt; fixedRateTasks;
	private List&lt;IntervalTask&gt; fixedDelayTasks;
	private final Map&lt;Task, ScheduledTask&gt; unresolvedTasks = new HashMap&lt;&gt;(16);
	private final Set&lt;ScheduledTask&gt; scheduledTasks = new LinkedHashSet&lt;&gt;(16);
	
	public void setTaskScheduler(TaskScheduler taskScheduler){...}
	public void setScheduler(@Nullable Object scheduler) {...}
	
	public ScheduledTask scheduleCronTask(CronTask task) {...}
	public ScheduledTask scheduleFixedRateTask(FixedRateTask task) {...}
	public ScheduledTask scheduleFixedDelayTask(IntervalTask task) {...}
}
</code></pre>
<p>以cron为例注册逻辑实现如下，把包装的Runnable方法和Trigger交由taskScheduler处理<br>
<img src="https://img-blog.csdnimg.cn/20200222162128286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>再看下TaskScheduler这里是个接口，分别提供了三种模式的定义如下</p>
<pre><code class="language-java">public interface TaskScheduler {
	// ****** cron支持  ******
	ScheduledFuture&lt;?&gt; schedule(Runnable task, Trigger trigger);
	ScheduledFuture&lt;?&gt; schedule(Runnable task, Date startTime);

	// ****** FixedRate支持  ******
	ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable task, Date startTime, long period);
	ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable task, long period);
	
	// ****** FixedDelay支持  ******
	ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable task, Date startTime, long delay);
	ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable task, long delay);

}
</code></pre>
<p>看到这里我们就大概明白了，上面分析可以总结为    <em><strong>提取定时方法委托给taskScheduler执行</strong></em>。这个***taskScheduler的实现才是线程模型的关键***。又上边ScheduledTaskRegistrar类我们可以看到taskScheduler是通过setTaskScheduler、setScheduler方法传入的，我们只需要找到这俩方法在上面地方被调用即可。<br>
<img src="https://img-blog.csdnimg.cn/202002221657347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><img src="https://img-blog.csdnimg.cn/20200222165749476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>这俩方法都是在ScheduledAnnotationBeanPostProcessor#finishRegistration处被调用，finishRegistration在onApplicationEvent()阶段被执行<br>
<img src="https://img-blog.csdnimg.cn/2020022217035698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
具体执行逻辑如下，注意两处判断逻辑，如果ScheduledAnnotationBeanPostProcessor实例的scheduler不为空就把它设置给ScheduledTaskRegistrar，否则进入下面加载逻。<br>
<img src="https://img-blog.csdnimg.cn/20200222171355130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>按照先类型、再名称顺序从容器中分别查找TaskScheduler、ScheduledExecutorService对象<br>
<img src="https://img-blog.csdnimg.cn/20200222171726611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>上述逻辑打断点发现默认通过this.registrar.setTaskScheduler(resolveSchedulerBean(this.beanFactory, TaskScheduler.class, false))方法加载到TaskScheduler实例，通过resolveNameBean得到一个NameBeanHolder实例，我们知道Spring 默认类别名为类名首字母小写，这里传入类型为TaskScheduler，holder.gerBeanName()为taskScheduler<br>
<img src="https://img-blog.csdnimg.cn/20200222172924489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
TaskScheduler的实现有如下三种<br>
<img src="https://img-blog.csdnimg.cn/20200222175259578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
通过debug发现加载的实例为ThreadPoolTaskScheduler类型<br>
<img src="https://img-blog.csdnimg.cn/20200222174926204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
到这里我们已经知道了***@Scheduled是如何被装载处理的*** 、 <strong>委托执行对象(定时器执行单元)是如何加载的</strong>以及***加载的对象是ThreadPoolTaskScheduler类型***，那为什么默认是这个类型呢？别忘了我们还有一个非常重要的注解@EnableScheduling，这个注解是定时任务的开关、并且会进行缺省配置。TaskSchedulingAutoConfiguration为自动配置类</p>
<p>从配置文件中加载默认配置构造TaskSchedulerBuilder对象并执行构建方法builder进行构建<br>
<img src="https://img-blog.csdnimg.cn/20200222184333203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>build()实现<br>
<img src="https://img-blog.csdnimg.cn/20200222184922770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
ThreadPoolTaskScheduler默认线程为1，内部依赖JDK ScheduledExecutorService实现<img src="https://img-blog.csdnimg.cn/20200222184956572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"> <img src="https://img-blog.csdnimg.cn/20200222185028735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
createExecutor()实现，可以看到创建了一个ScheduledExecutorService，默认poolSize为1<br>
<img src="https://img-blog.csdnimg.cn/2020022218542941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>由此分析与验证结果一致。<strong>@Scheduled注解默认采用单线程执行，执行单元是Spring 实现的ThreadPoolTaskScheduler封装了JDK JUC调度器ScheduledExecutorService实现。</strong></p>
<p>最后再往回翻代码发现，ScheduledAnnotationBeanPostProcessor#setScheduler(Object)方法的注释已经说的很清楚，如果不进行配置，默认实现为单线程。<br>
<img src="https://img-blog.csdnimg.cn/20200222190147831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>接下来就是解决问题了，请见下篇《Spring @Scheduled线程模型探究 - 解决问题》。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring @Scheduled线程模型探究 - 发现问题]]></title>
        <id>https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-fa-xian-wen-ti/</id>
        <link href="https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-fa-xian-wen-ti/">
        </link>
        <updated>2020-02-27T13:43:14.000Z</updated>
        <content type="html"><![CDATA[<p>最近工程中发现一个奇怪的问题，简单代码逻辑如下所示：</p>
<pre><code class="language-java">@EnableScheduling
@Component
public class SimpleImplement {
    private static final Logger LOG = LoggerFactory.getLogger(SimpleImplement.class);

    private volatile List&lt;String&gt; list = Collections.EMPTY_LIST;

    private final Queue&lt;Thread&gt; waiters = Queues.newConcurrentLinkedQueue();

    // 如果list为空挂起线程
    public List&lt;String&gt; get(){
        while(CollectionUtils.isEmpty(list)){
            try {
                Thread current = Thread.currentThread();
                waiters.add(current);
                LOG.info(&quot;list 为空挂起线程 {}.&quot;, current.getName());
                LockSupport.park();
            }catch (Exception e){}
        }
        return list;
    }

    // 异步更新list，如果list不为空则唤醒被挂起的线程
    @Scheduled(fixedDelay = 1000)
    private void sync(){
        // 加载数据
        list = ...;
        if(CollectionUtils.isNotEmpty(list)){
            Thread waiter = null;
            while (!waiters.isEmpty()){
                waiter = waiters.remove();
                LOG.info(&quot;同步数据 list 不为空唤醒线程 {}.&quot;, waiter.getName());
                LockSupport.unpark(waiter);
            }
        }
    }
</code></pre>
<p>上边代码对list异步加载，调用get接口的时候如果list为空就挂起当前线程，待有数据加载时再进行唤醒。我们知道加锁也可以实现等待唤醒，这里用LockSupport是因为这里是异步加载数据不存在数据竞争问题，加锁会让多个线程串行执行，影响任务执行效率。</p>
<p><em><strong>问题</strong></em><br>
get()接口在工程中好几处被调用，测试发现被挂起的线程有时会唤醒失败。反复测试几次从日志中看被阻塞的线程都是 scheduling-1，看起像是定时器的线程。于是翻看了代码发现几处调用get()接口的地方都采用@Scheduled注解进行周期轮询。</p>
<p><em><strong>分析</strong></em><br>
怀疑这里可能是@Scheduled的实现是单线程，几处定时任务都是有同一个线程执行，如果这样调用sync()接口的线程也是调用get()接口的线程，如果被阻塞那么唤醒动作就一直得不到执行。</p>
<p><em><strong>验证</strong></em><br>
为了验证我们的想法，写了个简单的测试代码及结果如下:</p>
<pre><code class="language-java">@Component
@EnableScheduling
public class ScheduledTest {
    private static Logger LOG = LoggerFactory.getLogger(ScheduledTest.class);

    @Scheduled(fixedDelay = 1000)
    public void method1(){
        LOG.info(&quot;线程 {} 执行method1 .&quot;, Thread.currentThread().getName());
    }

    @Scheduled(fixedDelay = 1000)
    public void method2(){
        LOG.info(&quot;线程 {} 执行method2 .&quot;, Thread.currentThread().getName());
    }
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020022214412263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
测试发现@Scheduled注解确实是单线程执行，执行method1和method2的线程都是scheduing-1，并且在打印完method1执行的log后5秒才打印method2的log，说明在这里scheduling-1在method1被阻塞了5秒。</p>
<p>这里刚好验证了我们的猜想：<strong>被挂起的线程没有被唤醒，是因为执行唤醒和被挂起的是同一个线程</strong>。</p>
<p>现在已经确定问题了，接下来就是怎么改。改之前去翻看下源码找到问题的根源，才能更好的解决问题，源码分析接下篇<a href="https://blog.csdn.net/zyc920716/article/details/104444109">《Spring @Scheduled线程模型探究 - 源码追踪》</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://yanchao0716.github.io/post/hello-gridea/</id>
        <link href="https://yanchao0716.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>