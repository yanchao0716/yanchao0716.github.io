<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yanchao0716.github.io</id>
    <title>yanchao&apos;s blog</title>
    <updated>2020-03-10T13:43:46.901Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yanchao0716.github.io"/>
    <link rel="self" href="https://yanchao0716.github.io/atom.xml"/>
    <subtitle>总有一件值得让你付出热情</subtitle>
    <logo>https://yanchao0716.github.io/images/avatar.png</logo>
    <icon>https://yanchao0716.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, yanchao&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[Netty -从ServerBootstrap入手分析内部实现]]></title>
        <id>https://yanchao0716.github.io/post/netty-cong-serverbootstrap-ru-shou-fen-xi-nei-bu-shi-xian/</id>
        <link href="https://yanchao0716.github.io/post/netty-cong-serverbootstrap-ru-shou-fen-xi-nei-bu-shi-xian/">
        </link>
        <updated>2020-03-08T16:42:43.000Z</updated>
        <content type="html"><![CDATA[<p>编写一个NIO Server用JDK NIO包实现非常繁琐，要绑定端口、监听客户端连接、监听数据、接收数据、处理数据。用Netty了了二三十行代码就实现了这些功能，我们知道Netty对JDK NIO进行了封装和改进，接下来从官方的Demo分析Netty的实现</p>
<pre><code class="language-java">public class DiscardServer {
    private int port;

    public DiscardServer(int port) {
        this.port = port;
    }

    public void run() throws Exception{
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup =  new NioEventLoopGroup();
        try {
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap
                    .group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                        protected void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new DiscardServerHandler());
                        }
                    })
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childOption(ChannelOption.SO_KEEPALIVE, true);

            ChannelFuture future = serverBootstrap.bind(port).sync();
            future.channel().closeFuture().sync();
        }finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }


    public static void main(String[] args) throws Exception {
        int port = 8080;
        if(args.length &gt; 0){
            port = Integer.valueOf(args[0]);
        }
        new DiscardServer(port).run();
    }
}

public class DiscardServerHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        super.channelRead(ctx, msg);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        super.exceptionCaught(ctx, cause);
    }
}
</code></pre>
<p>简化上边代码Netty的创建NIO Server的过程只需要几个步骤，按照以下几个步骤逐步解析</p>
<pre><code class="language-java">serverBootstrap
	.group() // 1
	.channel() // 2
	.childHandler() // 3
	.option() // 4
	.childOption() // 5
	.bind(); // 6
</code></pre>
<h2 id="1group-设置处理器">1.group() 设置处理器</h2>
<p>这里用来设置【处理用户请求的线程组】 和 【处理读写请求的线程组】。这里是reactor的核心部分，参见https://zhuanlan.zhihu.com/p/87630368</p>
<pre><code class="language-java">	@Override
    public ServerBootstrap group(EventLoopGroup group) {
        return group(group, group);
    }
    
     public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {
        super.group(parentGroup);
        if (this.childGroup != null) {
            throw new IllegalStateException(&quot;childGroup set already&quot;);
        }
        this.childGroup = ObjectUtil.checkNotNull(childGroup, &quot;childGroup&quot;);
        return this;
    }
</code></pre>
<p>ServerBootstrap类持有group、childGroup俩个线程组，其中group在父类AbstractBootstrap中声明，这里调用group参数只是简单的给内部成员赋值。parentGroup用来异步处理用户注册请求；childGroup用来做IO事件回调处理，特别注意的是这里一个channel对应一个EvenLoop，netty巧妙规避了多线程并发问题提高了性能</p>
<h2 id="2channel-设置channel类型">2.channel() 设置channel类型</h2>
<pre><code class="language-java">	// 设置channel类型
	public B channel(Class&lt;? extends C&gt; channelClass) {
		// 实际构建了一个channel工厂
        return channelFactory(new ReflectiveChannelFactory&lt;C&gt;(
                ObjectUtil.checkNotNull(channelClass, &quot;channelClass&quot;)
        ));
    }

	// 反射工厂的构造方法，实际保存了channel类的构造方法
	public ReflectiveChannelFactory(Class&lt;? extends T&gt; clazz) {
        ObjectUtil.checkNotNull(clazz, &quot;clazz&quot;);
        try {
            this.constructor = clazz.getConstructor();
        } catch (NoSuchMethodException e) {
            throw new IllegalArgumentException(&quot;Class &quot; + StringUtil.simpleClassName(clazz) +
                    &quot; does not have a public non-arg constructor&quot;, e);
        }
    }
	
	public B channelFactory(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory) {
        return channelFactory((ChannelFactory&lt;C&gt;) channelFactory);
    }
</code></pre>
<h2 id="3childhandler-设置处理器">3.childHandler() 设置处理器</h2>
<p>这里注册的是ChannelInitializer实现的，在服务端接受到连接的时候会调用initChannel方法给新建的channel设定一个处理器</p>
<pre><code class="language-java">.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                        protected void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new DiscardServerHandler());
                        }
                    })
</code></pre>
<h2 id="4option-childoption-channel参数配置">4.option()、childOption() channel参数配置</h2>
<p>配置channel参数，option对应的是boss线程组，childOption对应worker线程组，实现方别在AbstractBootstrap和ServerBootstrap，前者是后者的父类是个抽象类。boss线程组是在AbstractBootstrap里声明的，worker线程组是在ServerBootstrap中声明的。</p>
<h2 id="5bind-端口绑定">5.bind() 端口绑定</h2>
<pre><code>这里比较关键，执行bind方法，
</code></pre>
<pre><code class="language-java">	public ChannelFuture bind(int inetPort) {
        return bind(new InetSocketAddress(inetPort));
    }

	public ChannelFuture bind(SocketAddress localAddress) {
        validate();
        return doBind(ObjectUtil.checkNotNull(localAddress, &quot;localAddress&quot;));
    }

	private ChannelFuture doBind(final SocketAddress localAddress) {
		// 初始化并注册，这里很关键
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();
        if (regFuture.cause() != null) {
        	// 如果抛出异常，这里直接退出注册流程
            return regFuture;
        }
		
        if (regFuture.isDone()) {
            ChannelPromise promise = channel.newPromise();
            doBind0(regFuture, channel, localAddress, promise);
            return promise;
        } else {
            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
            regFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    Throwable cause = future.cause();
                    if (cause != null) {
                        promise.setFailure(cause);
                    } else {
                        promise.registered();
                        doBind0(regFuture, channel, localAddress, promise);
                    }
                }
            });
            return promise;
        }
    }
</code></pre>
<p>看下关键方法AbstractBootstrap.initAndRegister()</p>
<pre><code class="language-java">final ChannelFuture initAndRegister() {
        // 1.初始化channel
        Channel channel = null;
        try {
            channel = channelFactory.newChannel();
            init(channel);
        } catch (Throwable t) {
            if (channel != null) {
                channel.unsafe().closeForcibly();
                return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
            }
            return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
        }
		
		// 2.注册channel
        ChannelFuture regFuture = config().group().register(channel);
        if (regFuture.cause() != null) {
            if (channel.isRegistered()) {
                channel.close();
            } else {
                channel.unsafe().closeForcibly();
            }
        }
        return regFuture;
    }
</code></pre>
<ol>
<li>channelFactory.newChannel() 调用在第二步channel(Class&lt;? extends C&gt; channelClass)方法里构建的channelFactory来创建channel，然后调用init(channel)加载配置</li>
</ol>
<pre><code class="language-java">	public T newChannel() {
        try {
            return constructor.newInstance();
        } catch (Throwable t) {
            throw new ChannelException(&quot;Unable to create Channel from class &quot; + constructor.getDeclaringClass(), t);
        }
    }

	void init(Channel channel) {
        setChannelOptions(channel, options0().entrySet().toArray(EMPTY_OPTION_ARRAY), logger);
        setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));

        ChannelPipeline p = channel.pipeline();

        final EventLoopGroup currentChildGroup = childGroup;
        final ChannelHandler currentChildHandler = childHandler;
        final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions =
                childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);
        final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);

        p.addLast(new ChannelInitializer&lt;Channel&gt;() {
            @Override
            public void initChannel(final Channel ch) {
                final ChannelPipeline pipeline = ch.pipeline();
                ChannelHandler handler = config.handler();
                if (handler != null) {
                    pipeline.addLast(handler);
                }

                ch.eventLoop().execute(new Runnable() {
                    @Override
                    public void run() {
                        pipeline.addLast(new ServerBootstrapAcceptor(
                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                    }
                });
            }
        });
    }
</code></pre>
<ol start="2">
<li>
<p>config().group().register(channel)是注册channel到selector的方法。</p>
<pre><code> config().group()实则获取的boss线程，实现如下
</code></pre>
</li>
</ol>
<pre><code class="language-java">	public final ServerBootstrapConfig config() {
        return config;
    }
	
	public final EventLoopGroup group() {
        return bootstrap.group();
    }
</code></pre>
<p>这里有很多类都实现了register()方法，由于我们调用group方法传入的NioEventLoopGroup，而NioEventLoopGroup又继承自MultithreadEventLoopGroup，所以我们应该看MultithreadEventLoopGroup的实现。</p>
<pre><code class="language-java"> 	public ChannelFuture register(Channel channel) {
        return next().register(channel);
    }
</code></pre>
<p>next()方法实现很关键，用来选取一个EventLoop线程。调用链为MultithreadEventLoopGroup.next() -&gt; MultithreadEventExecutorGroup.next() -&gt; chooser.next() ，MultithreadEventExecutorGroup.next是MultithreadEventLoopGroup.next的父类，chooser是一个选择器封装了选取EventLoop线程的策略，netty自带实现有GenericEventExecutorChooser和PowerOfTwoEventExecutorChooser俩种</p>
<pre><code class="language-java"> private static final class PowerOfTwoEventExecutorChooser implements EventExecutorChooser {
        private final AtomicInteger idx = new AtomicInteger();
        private final EventExecutor[] executors;

        PowerOfTwoEventExecutorChooser(EventExecutor[] executors) {
            this.executors = executors;
        }

        @Override
        public EventExecutor next() {
            return executors[idx.getAndIncrement() &amp; executors.length - 1];
        }
    }

    private static final class GenericEventExecutorChooser implements EventExecutorChooser {
        private final AtomicInteger idx = new AtomicInteger();
        private final EventExecutor[] executors;

        GenericEventExecutorChooser(EventExecutor[] executors) {
            this.executors = executors;
        }

        @Override
        public EventExecutor next() {
            return executors[Math.abs(idx.getAndIncrement() % executors.length)];
        }
    }
</code></pre>
<p>选出一个EventLoop线程了,那接下来就看绑定方法register()的实现，实现在SingleThreadEventLoop里</p>
<pre><code class="language-java">	public ChannelFuture register(Channel channel) {
        return register(new DefaultChannelPromise(channel, this));
    }

    @Override
    public ChannelFuture register(final ChannelPromise promise) {
        ObjectUtil.checkNotNull(promise, &quot;promise&quot;);
        promise.channel().unsafe().register(this, promise);
        return promise;
    }
</code></pre>
<p>这里调用的AbstractChannel的内部类abstarctUnsafe，register0会被封装成异步让我</p>
<pre><code class="language-java">public final void register(EventLoop eventLoop, final ChannelPromise promise) {
            ObjectUtil.checkNotNull(eventLoop, &quot;eventLoop&quot;);
            if (isRegistered()) {
                promise.setFailure(new IllegalStateException(&quot;registered to an event loop already&quot;));
                return;
            }
            if (!isCompatible(eventLoop)) {
                promise.setFailure(
                        new IllegalStateException(&quot;incompatible event loop type: &quot; + eventLoop.getClass().getName()));
                return;
            }
			
			// 获取一个线程，这里是单线程实现的线程池
            AbstractChannel.this.eventLoop = eventLoop;

            if (eventLoop.inEventLoop()) {
                register0(promise);
            } else {
                try {
                	// 异步注册
                    eventLoop.execute(new Runnable() {
                        @Override
                        public void run() {
                            register0(promise);
                        }
                    });
                } catch (Throwable t) {
                    logger.warn(
                            &quot;Force-closing a channel whose registration task was not accepted by an event loop: {}&quot;,
                            AbstractChannel.this, t);
                    closeForcibly();
                    closeFuture.setClosed();
                    safeSetFailure(promise, t);
                }
            }
        }
</code></pre>
<p>register0()通过调用doRegister()方法进行注册</p>
<pre><code class="language-java"> 	private void register0(ChannelPromise promise) {
            try {
                if (!promise.setUncancellable() || !ensureOpen(promise)) {
                    return;
                }
                boolean firstRegistration = neverRegistered;
                // 这个方法很关键，真正执行注册实现在这里
                doRegister();
                neverRegistered = false;
                registered = true;

                pipeline.invokeHandlerAddedIfNeeded();

                safeSetSuccess(promise);
                pipeline.fireChannelRegistered();
                if (isActive()) {
                    if (firstRegistration) {
                        pipeline.fireChannelActive();
                    } else if (config().isAutoRead()) {
                        beginRead();
                    }
                }
            } catch (Throwable t) {
                closeForcibly();
                closeFuture.setClosed();
                safeSetFailure(promise, t);
            }
        }
</code></pre>
<p>doRegister()实现在AbstractNioChannel中</p>
<pre><code class="language-java">	protected void doRegister() throws Exception {
        boolean selected = false;
        for (;;) {
            try {
            	// 这里调用了JDK的NIO实现
                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
                return;
            } catch (CancelledKeyException e) {
                if (!selected) {
                    eventLoop().selectNow();
                    selected = true;
                } else {
                    throw e;
                }
            }
        }
    }
</code></pre>
<p>至此注册流程分析结束。最后做个回顾，使用Netty构建一个NIO server大致需要如下几个步骤：</p>
<ol>
<li>配置线程组，boss线程组负责处理用户请求、worker线程组负责处理IO</li>
<li>配置Channel类型，并设置相关参数，非阻塞等</li>
<li>设置处理器，不同方法分别对应建立连接、读写操作等事件</li>
<li>绑定端口，由选举器chooser 从NiOEventLoopGroup里选出一个EventLoop异步进行端口绑定。</li>
</ol>
<p>Netty的封装极大的简化了开发，同时boss线程组、worker线程组把accepter和reactor解耦分别用线程组来实现提升了性能。boss线程组异步设计使得能够处理更多的用户请求、worker线程组只需要比连接少的多的线程就可以处理IO回调。每个Channel和一个EventLoop绑定消除了多线程数据同步问题，无所设计也极大的提升了性能，使得netty更顺滑的处理大量IO请求。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JDK源码走读之ReentrantLock]]></title>
        <id>https://yanchao0716.github.io/post/jdk-yuan-ma-zou-du-zhi-reentrantlock/</id>
        <link href="https://yanchao0716.github.io/post/jdk-yuan-ma-zou-du-zhi-reentrantlock/">
        </link>
        <updated>2020-02-27T14:02:46.000Z</updated>
        <content type="html"><![CDATA[<p>ReentrantLock的功能几乎等同于Synchronized，在分析源码之前，我们首先来明确一下ReentrantLock要实现的功能，这样才能做到有的放矢。</p>
<ol>
<li>控制线程执行顺序。当线程获取锁进入Synchronized代码块（获取监视器），其余线程必须等待该线程执行完毕，才能继续执行该代码块。</li>
<li>提供线程通信功能。Synchronized关键字支持在其代码块中使用await、notify、notifyAll来进行线通信。执行await会使当前线程释放掉锁进入阻塞状态，直到被其他线程执行notify、notifyAll唤醒。</li>
</ol>
<p>ReentrantLock通过lock()、unlock()方法控制线程执行顺序，Condition.await()和Condition.signal()实现线程通信。</p>
<p><strong>类图</strong><br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTEzMjEwMjM4NzU2?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<p>ReentrantLock主要依赖AbstractQueuedSynchronized(以下简称AQS)实现。AQS继承父类AbstractOwnableSychronized特性能够持有一个线程，它自身还维护Node和ConditionObject两个队列。</p>
<ol>
<li>ReentrantLock使用AQS能够持有一个线程的特性来标识当前正在执行的线程。</li>
<li>ReentrantLock把Node队列用作同步队列，用来存放获取锁失败的线程；把ConditionObject用作阻塞队列，用来存放阻塞线程(执行await方法)。</li>
</ol>
<p><strong>定义</strong></p>
<pre><code>public class ReentrantLock {
	private final Sync sync;
	public void lock() {
        sync.lock();
    }
	public void unlock() {
        sync.release(1);
    }
	public Condition newCondition() {
        return sync.newCondition();
    }
	abstract static class Sync extends AbstractQueuedSynchronizer {...}
	static final class FairSync extends Sync{...}
	static final class NonfairSync extends Sync{...}
}

</code></pre>
<p>ReentrantLock使用策略模式提供公平锁和非公平锁两种实现。使用无参构造方法默认使用非公平策略，也可以使用带参构造方法来显示指定使用策略。<br>
公平策略类似FIFO，能保证等待时间最长的线程先执行。非公平策略不能保证这一点。</p>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcxMDQyNjA2?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></figure>
<p><strong>加锁(lock、tryLock)</strong></p>
<p>执行lock方法调用链如下，根据初始化时指定的策略调用FairSync.lock或NoneFairSync.lock<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcxMTIzMzE0?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<p><strong>公平锁</strong></p>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcxMzQyNzAw?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></figure>
<p>lock()方法调用acquire(int arg)方法实现加锁，在其爷爷类AQS中实现如下：</p>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcxNDIxNDY3?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></figure>
<p>首先调用tryAcquire(int arg)方法尝试获取锁，如果获取锁失败把当前线程加入同步队列，最后执行selfInterrupt()中断当前线程执行。</p>
<ol>
<li>使用AQS的tryAcquire(int arg)尝试获取锁，该方法由子类重写覆盖，实际执行的是上图公平锁的tryAcquire(int acquires)方法。如下<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcxNTE5NTQ1?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></li>
</ol>
<p>A. getState()方法获取线程状态(是否持有锁)，如果没有获取锁（c==0），执行b，否则执行c。(AQS用state变量标识线程的状态，每次获取锁会对state加1，0表示没有线程持有锁。)<br>
B. 如果没有比当前线程等待更长时间的线程，尝试使用CAS操作修改state状态用来标识当前线程已经获取锁，如果前两步都成功，则修改AQS持有线程为当前线程。<br>
C. state不为零，说明当前线程已经持有锁，则利用CAS操作对state加acquires。这里体现了锁的可重入性。即：如果当前线程已经持有锁，再次请求锁会对state进行加1，state的值就代表线程获取锁的次数。每次释放对其进行减1，直到state为0锁才真正被释放掉。</p>
<ol start="2">
<li>
<p>如果获取锁失败则执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)把线程加入同步队列，并不断轮询队列，直到队列头结点获取锁成功。<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcxODUyNzM2?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
</li>
<li>
<p>如果线程获取锁失败(第1步)，并且当前线程应该被阻断，则执行selfInterrupt()阻断线程执行。</p>
</li>
</ol>
<p><strong>非公平锁</strong><br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcxOTQ1NzUw?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<p>非公平锁与公平锁类似，实现相对简单。它不用关心是否有线程比当前线程等待时间更长，采用抢占式的方式执行，因此执行效率会更高一些。</p>
<ol>
<li>直接用CAS操作对state变量进行修改，如果修改成功则设置持有锁的线程为当前线程。这里设计的很巧妙，假设当前线程没有获取锁直接用compareAndSetState(0, 1)进行修改state值，而不是先获取state值，再进行一系列的操作进行修改state。由于锁重入的情况相对较少，这么设计有效的提高执行效率。</li>
<li>如果获取锁失败，则执行acquire(int arg)进行加锁，调用过程类似公平锁，tryAcquire(int arg)方法实际调用的是此处的tryAcquire(int acquires)方法，nofairTryAcquire方法在父类Sync中实现，相比公平锁的tryAcquire方法，少了hasQueuedPredecessors()方法判断是否有线程比当前线程等待时间更长。<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcyMTE3MTc5?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></li>
</ol>
<p><strong>释放锁(unlock)</strong><br>
解锁调用过程如下<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcyMTQ2NzIy?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<figure data-type="image" tabindex="4"><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcyMjA1NTEw?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcyMjI0NDIw?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcyMjQxMzI4?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></figure>
<ol>
<li>调用tryRelease(int relaese)方法释放锁，修改锁信息。从图中可以看到只有state的值为0时，才真正执行setExclusiveOwnerThread(null)释放锁。</li>
<li>如果释放锁成功，执行unparkSuccessor(Node node)唤醒下一个节点。代码如下：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcyMzU5MzIw?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></li>
</ol>
<p><strong>等待(await)</strong><br>
上文提到，ReentrantLock是借助AQS的ConditionObject队列实现的线程通信。</p>
<ul>
<li>执行await()方法，线程阻塞并加入ConditionObject队列</li>
<li>执行signal()方法，唤醒线程阻塞线程出队列。</li>
</ul>
<p>下面是ConditionObject.await()方法的实现<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcyNTAyNjgw?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<ol>
<li>把当前线程加入阻塞队列</li>
<li>如果当前线程不在同步队列中(说明该线程已经从同步队列出队，正在CPU上执行)，则不断尝试执行LockSupport.park(this)挂起该线程。</li>
</ol>
<p><strong>唤醒(signal)</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcyNjU0OTE1?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcyNzE5NDk1?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<ol>
<li>singal()和signalAll()方法类似notify和notifyAll方法。singal()方法只是使阻塞队列的第一个节点出队，而singalAll()则是所有节点都出队。</li>
<li>出队的节点执行transferForSingal(Node node)方法进行唤醒，并加入同步队列。<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTExMTcyODAyOTk2?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li>ReentrantLock提供公平锁和非公平锁两种加锁策略，非公平锁的执行效率比公平锁高。</li>
<li>线程获取锁(lock)成功会继续执行，失败则被加入同步队列。</li>
<li>线程间的通信是通过ConditionObject实现的，执行await线程入队，singal、singalAll线程出队。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JDK源码走读之深入理解线程池(ThreadPoolExecutor)]]></title>
        <id>https://yanchao0716.github.io/post/jdk-yuan-ma-zou-du-zhi-shen-ru-li-jie-xian-cheng-chi-threadpoolexecutor/</id>
        <link href="https://yanchao0716.github.io/post/jdk-yuan-ma-zou-du-zhi-shen-ru-li-jie-xian-cheng-chi-threadpoolexecutor/">
        </link>
        <updated>2020-02-27T14:02:10.000Z</updated>
        <content type="html"><![CDATA[<p>Java线程池提供了一个框架来统一管理线程，通过把提交任务和执行任务解耦，使开发者无需关心线程的运行状态，只要把任务提交给线程池既可。使用线程池有以下好处：</p>
<ol>
<li>减少在创建和销毁线程上所花的时间以及系统资源的开销</li>
<li>避免创建过多的线程导致系统资源过度消耗、系统执行效率低下</li>
</ol>
<p>线程池可以通过工厂类Executors创建，大致分为以下几种：</p>
<ol>
<li>newFixedThreadPool(int nThreads) 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</li>
<li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</li>
<li>newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</li>
<li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI4MjExMzE2NzU5?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></figure>
<p>下面深入源码来分析一下线程池的实现</p>
<h2 id="executor框架">Executor框架</h2>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI4MjExNDAwODEy?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
Executor接口是整个框架的基础，下面所有类和接口都是对Executor的扩展。ThreadPoolExecutor和ScheduledThreadPoolExecutor是线程池的俩个核心类，前者是普通的线程池，后者继承前者扩展了任务定时、延迟执行等功能。<br>
Executors则是一个工厂类，屏蔽了线程池的创建过程，通过调用不同的方法传入合适的参数类实例化不同类型的线程池。<br>
## ThreadPoolExecutor 定义##<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI4MjExNjA0MjYw?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
ThreadPoolExecutor主要由4部分构成</p>
<ol>
<li>线程池的状态，运行、终止、当前线程数等等，用于对线程池监控</li>
<li>工作队列，用来保存提交的任务，队列可以有不同类型的实现</li>
<li>工作（消费）线程，用来执行工作队列里的任务</li>
<li>提交任务方法，以及一些其他方法</li>
</ol>
<h2 id="任务处理流程">任务处理流程</h2>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI4MjExNzM1MDEz?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
线程池的核心是生产者消费者模型，提交一个新的任务主要流程如图所示：</p>
<ol>
<li>线程池里的线程是否小于核心线程数，如果是则创建一个新的线程执行任务，如果不是执行2</li>
<li>工作队列是否已满，如果没有满则把任务放入队列中，如果满了执行3</li>
<li>判断线程池是否已满（到达线程个数上限），如果没满则创建新的线程执行任务，如果满了执行4</li>
<li>按照定义的不同策略处理无法执行的任务，如直接抛弃任务、抛出异常等等</li>
</ol>
<h2 id="worker">Worker</h2>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI4MjExODU1Nzgz?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
Worker为ThreadPoolExecutor的静态内部类，实现了runnable接口并集成了AbstractQueuedSynchonrizer类，这个类有两个主要的成员变量。</p>
<ol>
<li>
<pre><code>firstTask用来保存runnable任务，提交新任务到线程池，当核心线程池不满时会创建worker并且把提交的任务赋给这个worker，确保当前任务优先执行。
</code></pre>
</li>
<li>
<pre><code>thread对象，每创建一个worker都会对应创建一个thread对象，并且把worker自身作为task传入thread，这样执行thread.start就可以调用到worker的run方法
</code></pre>
</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI4MjEyMDI0NTcz?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
Worker的run方法调用外部类的runWorker方法</p>
<ol>
<li>循环调用getTask()方法获取队列中的任务执行，执行前加锁执行结束释放锁</li>
<li>执行任务前后根据业务场景自定义beforeExecute和afterExecute方法</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI4MjEyMjA1MDc5?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
getTask方法会不断的循环，从队列中取任务</p>
<ol>
<li>workQueue.take：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务，并执行；</li>
<li>workQueue.poll：如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null；</li>
</ol>
<h2 id="提交任务">提交任务</h2>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI4MjEyMjU2MTY1?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
调用execute(Runnable command)方法把任务提交到线程池</p>
<ol>
<li>线程池里的线程小于核心线程数，创建新的线程</li>
<li>队列未满(往队列里添加任务成功)</li>
<li>当核心线程已满，队列已满的情况下尝试创建非核心线程</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI4MjEyMzU0MDAy?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></figure>
<ol start="4">
<li>首选判断线程池的状态，如果线程池的状态值大于SHUTDOWN，则不处理提交任务，直接返回</li>
<li>如果线程数量不满足要求，则直接返回不做处理。添加核心线程要求当前线程数小于核心线程数；添加非核心线程要求当前线程数小于线程池数量上限；且线程最大不能超过最大容量</li>
<li>利用CAS尝试修改线程个数使其+1，如果成功则直接跳出循环，开始创建线程</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI4MjEyNTI2MjU3?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></figure>
<ol>
<li>把提交的任务最为task构造worker</li>
<li>把任务添加到工作队列，在添加之前获取锁添加完成释放，防止并发造成数据异常</li>
<li>最后执行t.start()启动worker，worker会通过run方法调用外部类的runWorker方法不断的从任务队列中消费任务</li>
</ol>
<h2 id="创建线程池">创建线程池</h2>
<figure data-type="image" tabindex="4"><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI4MjEyNjUyOTk1?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></figure>
<ol>
<li>corePoolSize 核心线程数线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</li>
<li>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；</li>
<li>线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用；</li>
<li>keepAliveTime的单位；</li>
<li>用来保存执行任务的阻塞队列，该队列泛型限制只接收Runnable类型的元素。根据传入的队列性质不同，线程池的特性也不同。</li>
</ol>
<p>Executors是对构造方法的封装，通过传入不同的参数，使线程池具有不同的特性，不再详细描述。</p>
<h2 id="总结">总结</h2>
<ol>
<li>每个worker对应一个thread，线程池通过控制worker的数量来控制并发线程数</li>
<li>线程池实质是一个生产者消费者模型，它有一个任务队列和一个消费线程集合组成。</li>
<li>任务通常会被提交到队列中，由消费线程执行。</li>
<li>运行的worker线程会通过run方法调用外部类的runWorker方法不断消费任务。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入源码剖析Thread.join实现]]></title>
        <id>https://yanchao0716.github.io/post/shen-ru-yuan-ma-pou-xi-threadjoin-shi-xian/</id>
        <link href="https://yanchao0716.github.io/post/shen-ru-yuan-ma-pou-xi-threadjoin-shi-xian/">
        </link>
        <updated>2020-02-27T14:01:38.000Z</updated>
        <content type="html"><![CDATA[<p>java.lang.Thread类提供一个方法join可以阻塞主线程(调用join方法的线程)，直到当前线程执行完。用法如下：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI3MjMxNTU3Nzk5?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<p>join会保证t2在t1线程执行完退出之后再执行，程序执行结果总是如下<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI3MjMxNjMxODI5?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<h2 id="定义">定义</h2>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI3MjMxNzI1OTIw?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></figure>
<h2 id="实现">实现</h2>
<p>该方法掉用了join（0）方法， 我们跟进查看具体实现。注意这里是一个静态方法加了同步锁，锁的是this，也就是当前类实例。我们知道在线程获取了锁以后再执行wait方法，会让线程释放掉锁，并且进入到等待阻塞状态，线程被唤醒或等待一定时间之后以后获取锁后会重新从wait的地方往下执行。<br>
作者巧用了这个原理，先获取锁再调用wait(0)释放锁并让主线程进入等待阻塞。并且循环执行，一旦主线程重新获取锁就立马释放。这样就保证了主线程一直得不到执行。<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI3MjMxODEzMzky?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<p>按照上诉代码，如果执行t.join(10 * 1000)那么主线程会阻塞10s，而事实并非如此，请看下面测试代码<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI3MjMxODQzMDU0?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<p>输出如下<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI3MjMxOTA2NDEx?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<p>这说明t线程执行完，main线程就得到执行，并没有阻塞10s，也就是说main线程得到了唤醒。翻看JVM源码发现在线程结束的时候会调用lock.notify_all(thread)唤醒线程<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI3MjMxOTMyMzU5?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<h2 id="总结">总结</h2>
<ol>
<li>java.lang.Thread.join方法通过循环阻塞主线程的方式保证当前线程优先执行</li>
<li>当前线程执行完之后会立马唤醒主线程继续执行</li>
</ol>
<p>文章参考：https://www.zhihu.com/question/44621343/answer/97640972</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JDK源码走读之LinkedList]]></title>
        <id>https://yanchao0716.github.io/post/jdk-yuan-ma-zou-du-zhi-linkedlist/</id>
        <link href="https://yanchao0716.github.io/post/jdk-yuan-ma-zou-du-zhi-linkedlist/">
        </link>
        <updated>2020-02-27T14:01:12.000Z</updated>
        <content type="html"><![CDATA[<p>LinkedList本质是一个双端链表，双端链表区别于双向链表，双向链表之链表的首位相连，而双端链表则分别持有链表头尾两个节点，访问时既可以从头开始，也可以从尾部开始。</p>
<p>链表结构<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI0MTY1NTMwMjAy?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<h2 id="定义">定义</h2>
<p>LinkedList实现了List、Dequet接口使它兼具二者的特性，既支持集合的添加删除操作，又支持队列的出队入队操作</p>
<pre><code>public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements
		List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable {
	transient int size = 0;
	transient Node&lt;E&gt; first; // 队列头
	transient Node&lt;E&gt; last; // 队列尾

	......

	private static class Node&lt;E&gt; {
		E item;
		Node&lt;E&gt; next;
		Node&lt;E&gt; prev;

		Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
			this.item = element;
			this.next = next;
			this.prev = prev;
		}
	}
}
</code></pre>
<h2 id="核心方法">核心方法</h2>
<p>ArraList提供了对队列操作的几个核心方法，包括把数据添加到队列头部、中间、尾部，以及对应的移除方法。<br>
其他List类型的add、get、remove等相关API实现，以及队列类型的push、pop、peek等相关的API实现，都是对这些核心方法的调用不再赘述。</p>
<pre><code>// 把元素添加到队列头，并把添加入节点和first节点连接
	// 新节点后继指向first节点，first节点前继指向新节点
    private void linkFirst(E e) {
        final Node&lt;E&gt; f = first;
        // 创建一个新的节点，prev为null，next为当前头结点
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);
        first = newNode;
        if (f == null)
        	// 如果当前头节点为null，说明队列为空，
        	// 新加入的节点既是头节点又是尾节点
            last = newNode;
        else
        	// 如果当前头结点不为空，
        	// 则把头结点的prev指向新节点
            f.prev = newNode;
        size++;
        modCount++;
    }

    // 把元素添加到尾节点，并把last节点和新节点连接
    // last节点的后继指向新节点，新节点的前继指向last
    void linkLast(E e) {
        final Node&lt;E&gt; l = last;
        // 创建一个新的节点，prev为尾节点，next为null
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
        last = newNode;
        if (l == null)
        	// 如果尾节点为空，说明队列为空
        	// 新加入的节点既是头节点又是尾节点
            first = newNode;
        else
        	// 如果当前头结点不为空，
        	// 则把尾节点的next指向新节点
            l.next = newNode;
        size++;
        modCount++;
    }

    // 在指定节点E的前边插入新节点
    void linkBefore(E e, Node&lt;E&gt; succ) {
        // assert succ != null;
        final Node&lt;E&gt; pred = succ.prev;
        // 创建节点，prev指向指定节点E的prev，next指向执行节点
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);
        // 把指定节点的prev指向新节点
        succ.prev = newNode;
        if (pred == null)
            // 如果指定节点E的前继节点为null，说明指定节点为头节点
        	// 新插入的节点在头结点之前，成为新的头结点
        	first = newNode;
        else
            pred.next = newNode;
        size++;
        modCount++;
    }

    // 移除头结点，头结点的next节点晋升为新的头结点
    private E unlinkFirst(Node&lt;E&gt; f) {
        // assert f == first &amp;&amp; f != null;
        final E element = f.item;
        final Node&lt;E&gt; next = f.next;
        // 释放引用，以便GC回收引用的对象
        f.item = null;
        f.next = null;
        // 把头结点的next设为头结点
        first = next;
        if (next == null)
        	// 如果头结点的next为null，说明队列中只有一个元素，
        	// 释放头结点之后队列为空，头尾节点都为null
            last = null;
        else
            next.prev = null;
        size--;
        modCount++;
        return element;
    }

    // 移除尾节点
    private E unlinkLast(Node&lt;E&gt; l) {
        // assert l == last &amp;&amp; l != null;
        final E element = l.item;
        final Node&lt;E&gt; prev = l.prev;
        // 释放引用，以便GC回收引用的对象
        l.item = null;
        l.prev = null; 
        last = prev;
        if (prev == null)
        	// 如果前继节点为null，说明队列中只有一个元素，
        	// 释放尾节点之后队列为空，头尾节点都为null
            first = null;
        else
            prev.next = null;
        size--;
        modCount++;
        return element;
    }

    // 释放任意节点，并使节点的pre、next互为前继、后继节点
    E unlink(Node&lt;E&gt; x) {
        // assert x != null;
        final E element = x.item;
        final Node&lt;E&gt; next = x.next;
        final Node&lt;E&gt; prev = x.prev;
        
        if (prev == null) {
        	// 如果节点的前继节点为空，说明当前节点是头结点
        	// 把当前节点的后继节点作为头节点
            first = next;
        } else {
        	// 前继节点的next指向后继节点
            prev.next = next;
            x.prev = null;
        }

        if (next == null) {
        	// 如果当前节点的后继节点为空，则说明是尾节点
        	// 删除当前节点之后，其前继节点作为尾节点
            last = prev;
        } else {
        	// 删除当前节点之后，后继节点的prev指向前继节点
            next.prev = prev;
            x.next = null;
        }
        // 释放节点引用的对象，以便GC回收
        x.item = null;
        size--;
        modCount++;
        return element;
}
</code></pre>
<h2 id="查找方法">查找方法</h2>
<p>获取队列某个位置的元素，去元素时首先根据给定的偏移量判断元素从距离头部和尾部哪一端更近，再从近端开始遍历查找。 这是双端队列优势的体现。如一个长度为10000的队列，要获取第9999个元素，如果采用单端队列存储需要从第一个元素开始遍历到9999个元素；使用双端队列只需要从尾部开始往前遍历取第二个。</p>
<pre><code>Node&lt;E&gt; node(int index) {
	// 如果在队列的前半部分
	if (index &lt; (size &gt;&gt; 1)) {
		Node&lt;E&gt; x = first;
		for (int i = 0; i &lt; index; i++)
			x = x.next;
		return x;
	// 如果在队列的后半部分
	} else {
		Node&lt;E&gt; x = last;
		for (int i = size - 1; i &gt; index; i--)
			x = x.prev;
		return x;
	}
}
</code></pre>
<h2 id="清空队列">清空队列</h2>
<pre><code>// 清空队列
public void clear() {
	// 遍历队列，移除队列中的所有元素
	for (Node&lt;E&gt; x = first; x != null; ) {
		Node&lt;E&gt; next = x.next;
		// 释放队列中的元素，以便GC回收
		x.item = null;
		x.next = null;
		x.prev = null;
		x = next;
	}
	first = last = null;
	size = 0;
	modCount++;
}
</code></pre>
<h2 id="总结">总结</h2>
<ol>
<li>LinkedList有较高的插入、删除效率和不错的查询效率，对队列的头尾进行操作时间复杂度为O(1)，在指定位置操作时间复杂度为O(n)。</li>
<li>LinkedList不是线程线程安全的。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JDK源码走读之ArrayList]]></title>
        <id>https://yanchao0716.github.io/post/jdk-yuan-ma-zou-du-zhi-arraylist/</id>
        <link href="https://yanchao0716.github.io/post/jdk-yuan-ma-zou-du-zhi-arraylist/">
        </link>
        <updated>2020-02-27T14:00:39.000Z</updated>
        <content type="html"><![CDATA[<p>ArrayList其实就是动态数据，它封装了初始化、添加、删除、遍历等操作，并加入了泛型支持，下面我们从几个方面来分析一下ArrayList的实现。</p>
<h2 id="定义">定义</h2>
<pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
{
    private static final long serialVersionUID = 8683452581122892189L;
    private static final int DEFAULT_CAPACITY = 10;
    private static final Object[] EMPTY_ELEMENTDATA = {};
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    transient Object[] elementData; // non-private to simplify nested class access
    private int size;
	
    ….
}
</code></pre>
<h2 id="初始化">初始化</h2>
<p>初始化的时候可以指定数组大小，系统会按照指定大小初始化数组；如果不指定大小则默认为空数组。</p>
<pre><code>public ArrayList(int initialCapacity) {
        if (initialCapacity &gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        }
    }
    
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
</code></pre>
<h2 id="添加元素">添加元素</h2>
<p>1.调用add(E e)方法添加元素，默认会添加到数据的最后，添加元素之前首先要确保当前数组有空间能够接纳新元素，如果空间不够则进行扩容</p>
<pre><code>public boolean add(E e) {
    // 确保数组有足够的空间接纳新元素
        ensureCapacityInternal(size + 1);
        elementData[size++] = e;
        return true;
}

private void ensureCapacityInternal(int minCapacity) {
	if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
		minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
	}
	ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
	modCount++;
    // 如果数组长度不满足要求，则进行扩容，具体实现参考数据扩容
	if (minCapacity - elementData.length &gt; 0)
		grow(minCapacity); 
}
</code></pre>
<p>2.调用把元素添add(int index, E element)方法把元素加到指定位置，具体实现如下</p>
<pre><code>public void add(int index, E element) {
	rangeCheckForAdd(index);
	ensureCapacityInternal(size + 1);
// 调用native方法在数据中间插入元素
	System.arraycopy(elementData, index, elementData, index + 1,
					 size - index);
	elementData[index] = element;
	size++;
}
</code></pre>
<h2 id="数组扩容">数组扩容</h2>
<p>数组的最大长度为Integer.MAX_VALUE - 8 即2147483639，进行数据扩容时首先要确保新申请的数据长度不能超过该值，然后调用底层native方法开辟新数据，并把数据复制进去</p>
<pre><code>private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

private void grow(int minCapacity) {
	int oldCapacity = elementData.length;
	// 默认数组长度扩大为当前长度的1.5倍
	int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
	if (newCapacity - minCapacity &lt; 0)
		newCapacity = minCapacity;
	// 确保数组最大长度不超过MAX_ARRAY_SIZE
	if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
		newCapacity = hugeCapacity(minCapacity);
	// 开辟新数组，并把移动到新数组中。
	elementData = Arrays.copyOf(elementData, newCapacity);
}

private static int hugeCapacity(int minCapacity) {
	if (minCapacity &lt; 0) // overflow
		throw new OutOfMemoryError();
	// 如果申请长度超过上限
	return (minCapacity &gt; MAX_ARRAY_SIZE) ?
		Integer.MAX_VALUE :
		MAX_ARRAY_SIZE;
}

Arrays.copyOf(elementData, newCapacity)方法实现如下

public static &lt;T&gt; T[] copyOf(T[] original, int newLength) {
	return (T[]) copyOf(original, newLength, original.getClass());
}

public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {
    // 判断数组类型是否匹配，如果不匹配则调用native方法开辟新数组
	T[] copy = ((Object)newType == (Object)Object[].class)
		? (T[]) new Object[newLength]
		// native方法
		: (T[]) Array.newInstance(newType.getComponentType(), newLength);
	// native方法
	System.arraycopy(original, 0, copy, 0,
					 Math.min(original.length, newLength));
	return copy;
}
</code></pre>
<h2 id="删除元素">删除元素</h2>
<p>1.remove(int index)方法可以删除指定位置的元素，调用该方法会直接移除对应下边的元素，并对数据进行整理(调用System.arraycopy方法进行复制)，这样可以有效的减小对内存空间的占用，但是由于其需要整理内存，相对来说代价较大。</p>
<pre><code>public E remove(int index) {
	// 检查是否越界
	rangeCheck(index);

	modCount++;
	E oldValue = elementData(index);

	int numMoved = size - index - 1;
	if (numMoved &gt; 0)
		// 把删除元素【之前的部分】和【之后的部分】拼接
		System.arraycopy(elementData, index+1, elementData, index,
						 numMoved);
	// 释放引用，这样GC的时候就能被回收
	elementData[--size] = null; 

	return oldValue;
}
</code></pre>
<p>2.remove(Object o)移除数组中o元素，通过循环遍历定位到o元素，并进行移除。该方法没有直接进行内存整理，而是释放数据对元素的引用，这样在GC的时候就可以回收o元素，但是o对应的数据位置会被赋值为null，并不会被释放。</p>
<pre><code>public boolean remove(Object o) {
	// 循环超找元素，找到之后进行清理，并返回true
	if (o == null) {
		for (int index = 0; index &lt; size; index++)
			if (elementData[index] == null) {
				fastRemove(index);
				return true;
			}
	} else {
		for (int index = 0; index &lt; size; index++)
			if (o.equals(elementData[index])) {
				fastRemove(index);
				return true;
			}
	}
	return false;
}
</code></pre>
<h2 id="总结">总结</h2>
<ol>
<li>数据扩容需要调用底层重新开辟内存空间，并进行数据的移动，使用ArrayList在初始化的时候尽量指定合适的容量，以避免数据频繁扩容</li>
<li>数据的默认大小是10，每次扩容变为原来的1.5倍，即15、22、33.....</li>
<li>ArrayList查询较快，时间复杂度为O(1)，（指定位置）添加元素和（指定位置）删除元素较慢平均时间复杂度为O(n)</li>
<li>尽量避免频繁调用add(int index, E element)和remove(int index)方法，这两个方法会调用System.copy对内存进行整理，相对代价较大</li>
<li>ArrayList不是线程安全的，并发场景下可以使用vector替代</li>
</ol>
<p>注:以上源码为JDK1.8</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何优雅的停止服务（ShutdownHook）]]></title>
        <id>https://yanchao0716.github.io/post/ru-he-you-ya-de-ting-zhi-fu-wu-shutdownhook/</id>
        <link href="https://yanchao0716.github.io/post/ru-he-you-ya-de-ting-zhi-fu-wu-shutdownhook/">
        </link>
        <updated>2020-02-27T13:58:11.000Z</updated>
        <content type="html"><![CDATA[<p>JDK提供了Runtime.addShutdownHook(Thread hook)方法用来注册一个钩子(线程)，在Java程序退出时会调用这个钩子来清理现场。</p>
<p>这个钩子会在以下场景中被调用：</p>
<ol>
<li>程序正常退出</li>
<li>使用System.exit()</li>
<li>终端使用Ctrl+C触发的中断</li>
<li>系统关闭</li>
<li>OutOfMemory宕机</li>
<li>使用Kill pid命令干掉进程（注：在使用kill -9 pid时，是不会被调用的）</li>
</ol>
<p>下面我们来简单的模拟一个服务，详细说明如何优雅的终止Java进程。</p>
<pre><code>/**
 * zyc 2017年10月16日 下午3:05:03
 */
public class ShutdownHookTest{
	private static ExecutorService executorService = Executors.newFixedThreadPool(10);
	private static final long TIMEOUT = 10 * 1000;
	
	public static void main(String[] args) {
		
		// 注册钩子函数，在JVM接收到停止指令后会运行该线程
		Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;invoke shutdownhook ....&quot;);
				// 调用该方法把threadpool 的 shutdown 设置为true，不再接受提交任务，
				// 等待已经提交的任务执行完之后才会退出
				executorService.shutdown(); 
				long time = System.currentTimeMillis();
				while(true){
					int activeCount = ((ThreadPoolExecutor)executorService).getActiveCount(); // 执行中的线程数
					int waitCount = ((ThreadPoolExecutor)executorService).getQueue().size(); // 等待的线程数
					System.out.println(&quot;there are &quot; + waitCount + &quot; threads wait ....&quot;);
					System.out.println(&quot;there are &quot; + activeCount + &quot; threads working ....&quot;);
					if(executorService.isTerminated()){ // 等待线程池退出
						System.out.println(&quot;thread pool is shutdown ...&quot;);
						break;
					}
					if(System.currentTimeMillis() - time &gt; TIMEOUT) // 超时
						executorService.shutdownNow();
					sleep(500);
				}
			}
		}));
		
		// 模拟工作环境，不断往线程池提交任务
		for(;;){
			if(executorService.isShutdown())
				break;
			executorService.submit(new Runnable() {
				@Override
				public void run() {
					String name = Thread.currentThread().getName();
					System.out.println(name + &quot; work ....&quot;);
					sleep(2 * 1000); // 模拟线程工作
				}
			});
			sleep(500);
		}
	}
	
	
	private static void sleep(long millis){
		try {
			TimeUnit.MILLISECONDS.sleep(millis);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

</code></pre>
<p>把代码打成Jar包在linux上运行 java –jar ShutdownHookTest.jar，输出如下：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTUwNTUzODc3?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
线程池在持续工作，并不断的有任务提交。</p>
<p>执行kill命令终止Java进程<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTUwNjQ1MDU0?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
注意：这里用的是kill -15 pid 不是kill -9 pid</p>
<p>Java进程接收到终止指令后，调用钩子方法，直到线程池里的所有任务都执行完毕才退出<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTUwNzU4NzQ4?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<p>本文简单的模拟了关闭服务的场景，通过不断的轮询线程池的状态，直到所有提交的任务执行完毕才终止进程，清理的逻辑在钩子函数的run方法中实现即可，更多的功能请各位自己尝试。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 死锁分析]]></title>
        <id>https://yanchao0716.github.io/post/java-si-suo-fen-xi/</id>
        <link href="https://yanchao0716.github.io/post/java-si-suo-fen-xi/">
        </link>
        <updated>2020-02-27T13:56:23.000Z</updated>
        <content type="html"><![CDATA[<p>发生死锁需要满足4个条件：</p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p>下面代码模拟了死锁：</p>
<pre><code>package me.zyc.lock.test;

public class DeadLock{
	public static void methodA(){
		String thread_name = Thread.currentThread().getName();
		System.out.println(thread_name + &quot; acquiring lock on LockA.class&quot;);
		synchronized (LockA.class) {
			System.out.println(thread_name + &quot; locked on LockA.class&quot;);
			doSomething(); // wait other thread lock on LockB
			System.out.println(thread_name + &quot; acquiring lock on LockB.class&quot;);
			synchronized (LockB.class) {
				System.out.println(thread_name + &quot;locked on LockB.class&quot;);
				if(true) for(;;){}
			}
			System.out.println(thread_name + &quot; released lock on LockB.class&quot;);
		}
		System.out.println(thread_name + &quot; released lock on LockA.class&quot;);
	}
	
	public static void methodB(){
		String thread_name = Thread.currentThread().getName();
		System.out.println(thread_name + &quot; acquiring lock on LockB.class&quot;);
		synchronized (LockB.class) {
			System.out.println(thread_name + &quot; locked on LockB.class&quot;);
			doSomething();  // wait other thread lock on LockA
			System.out.println(thread_name + &quot; acquiring lock on LockA.class&quot;);
			synchronized (LockA.class) {
				System.out.println(thread_name + &quot; locked on LockA.class&quot;);
				if(true) for(;;){}
			}
			System.out.println(thread_name + &quot; released lock on LockA.class&quot;);
		}
		System.out.println(thread_name + &quot; released lock on LockB.class&quot;);
	}
	
	public static void doSomething(){
		try {
			Thread.sleep(300);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	} 
	
	public static void main(String[] args) {
		new Thread(new Runnable() {
			public void run() {
				DeadLock.methodA();
			}
		}).start();
		
		new Thread(new Runnable() {
			public void run() {
				DeadLock.methodB();
			}
		}).start();
	}
	private class LockA{}
	private class LockB{}
}

</code></pre>
<p>代码运行输出如下：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI4MTQwNzUzOTYx?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<ol>
<li>thread-0 获取了锁LockA，thread-1 获取了锁LockB。</li>
<li>thread-0 尝试获取LockB，但是由于thread-1一直占用LockB未释放，thread-0被阻塞。</li>
<li>thread-1尝试获取LockA，但是由于thread-0一直占用LockA未释放，thread-1被阻塞</li>
</ol>
<p>jstack是Java自带线程分析工具，用法如下：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI4MTQxNzAyMjYy?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<p>执行jstack -l pid，结果如下：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI4MTQxNzM5ODg2?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<ol>
<li>thread-0 和 thread-1均处于<strong>BLOCKED</strong>状态。</li>
<li>thread-0 获取了锁LockA，并等待获取LockB。</li>
<li>thread-1 获取了锁LockB，并等待获取LockjA。</li>
</ol>
<p>在最后jstack给出了更详细的死锁信息<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI4MTQyMzM1ODM2?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring @Scheduled线程模型探究 - 源码追踪]]></title>
        <id>https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-yuan-ma-zhui-zong/</id>
        <link href="https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-yuan-ma-zhui-zong/">
        </link>
        <updated>2020-02-27T13:49:15.000Z</updated>
        <content type="html"><![CDATA[<p>接<a href="https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-fa-xian-wen-ti/">上一篇</a>我们来分析一下 @Scheduled 这个定时器的注解实现</p>
<p>首先我看下@Scheduled注解的定义</p>
<pre><code class="language-java">package org.springframework.scheduling.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(Schedules.class)
public @interface Scheduled {
	String CRON_DISABLED = &quot;-&quot;;
	String cron() default &quot;&quot;;
	String zone() default &quot;&quot;;
	long fixedDelay() default -1;
	String fixedDelayString() default &quot;&quot;;
	long fixedRate() default -1;
	String fixedRateString() default &quot;&quot;;
	long initialDelay() default -1;
	String initialDelayString() default &quot;&quot;;
}
</code></pre>
<p>注解的字段分别对cron表达式、fixedDelay、fixRate进行了支持，可以传入value</p>
<p>紧接着我们看下@Scheduled在哪里被用到，跟进去查看一下实现<br>
<img src="https://img-blog.csdnimg.cn/20200222151601696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>这里我们主要看ScheduledAnnotationBeanPostProcessor这个类，其他几个类我们稍后再说。<br>
<img src="https://img-blog.csdnimg.cn/20200222154351658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>ScheduledAnnotationBeanPostProcessor是spring BeanPostProcessor的实现，postProcessAfterInitialization(Object bean, String beanName)方法在Bean初始化之后执行。</p>
<ol>
<li>提取定时方法：抽取@Scheduled注解以及被注解的方法</li>
<li>处理定时方法：对定时方法进行注册委托给定时器，通过processScheduled()方法实现</li>
</ol>
<p>processScheduled方法提取了注解上的值，cron、fixedDelay、fixRate分别包装成不同的对象，通过registrar.scheduleCronTask方法注册到registrar中</p>
<pre><code class="language-java">protected void processScheduled(Scheduled scheduled, Method method, Object bean) {
		 	Runnable runnable = createRunnable(bean, method);
			Set&lt;ScheduledTask&gt; tasks = new LinkedHashSet&lt;&gt;(4);
			
			// 确定定时器初始延迟时间
			long initialDelay = scheduled.initialDelay();
			String initialDelayString = scheduled.initialDelayString();
			...
			initialDelay = parseDelayAsLong(initialDelayString);
			...

			// cron表达式实现
			String cron = scheduled.cron();
			...
			tasks.add(this.registrar.scheduleCronTask(new CronTask(runnable, new CronTrigger(cron, timeZone))));
			...

			// fixed delay实现
			long fixedDelay = scheduled.fixedDelay();
			...
			tasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay)));
			...

			// fixed rate实现
			long fixedRate = scheduled.fixedRate();
			...
			tasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay)));
			...
		}
	}
</code></pre>
<p>registrar是ScheduledTaskRegistrar类的实例，ScheduledTaskRegistrar类主要结构如下</p>
<pre><code class="language-java">public class ScheduledTaskRegistrar implements ScheduledTaskHolder, InitializingBean, DisposableBean {
	private TaskScheduler taskScheduler;
	private ScheduledExecutorService localExecutor;
	private List&lt;TriggerTask&gt; triggerTasks;
	private List&lt;CronTask&gt; cronTasks;
	private List&lt;IntervalTask&gt; fixedRateTasks;
	private List&lt;IntervalTask&gt; fixedDelayTasks;
	private final Map&lt;Task, ScheduledTask&gt; unresolvedTasks = new HashMap&lt;&gt;(16);
	private final Set&lt;ScheduledTask&gt; scheduledTasks = new LinkedHashSet&lt;&gt;(16);
	
	public void setTaskScheduler(TaskScheduler taskScheduler){...}
	public void setScheduler(@Nullable Object scheduler) {...}
	
	public ScheduledTask scheduleCronTask(CronTask task) {...}
	public ScheduledTask scheduleFixedRateTask(FixedRateTask task) {...}
	public ScheduledTask scheduleFixedDelayTask(IntervalTask task) {...}
}
</code></pre>
<p>以cron为例注册逻辑实现如下，把包装的Runnable方法和Trigger交由taskScheduler处理<br>
<img src="https://img-blog.csdnimg.cn/20200222162128286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>再看下TaskScheduler这里是个接口，分别提供了三种模式的定义如下</p>
<pre><code class="language-java">public interface TaskScheduler {
	// ****** cron支持  ******
	ScheduledFuture&lt;?&gt; schedule(Runnable task, Trigger trigger);
	ScheduledFuture&lt;?&gt; schedule(Runnable task, Date startTime);

	// ****** FixedRate支持  ******
	ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable task, Date startTime, long period);
	ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable task, long period);
	
	// ****** FixedDelay支持  ******
	ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable task, Date startTime, long delay);
	ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable task, long delay);

}
</code></pre>
<p>看到这里我们就大概明白了，上面分析可以总结为    <em><strong>提取定时方法委托给taskScheduler执行</strong></em>。这个***taskScheduler的实现才是线程模型的关键***。又上边ScheduledTaskRegistrar类我们可以看到taskScheduler是通过setTaskScheduler、setScheduler方法传入的，我们只需要找到这俩方法在上面地方被调用即可。<br>
<img src="https://img-blog.csdnimg.cn/202002221657347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><img src="https://img-blog.csdnimg.cn/20200222165749476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>这俩方法都是在ScheduledAnnotationBeanPostProcessor#finishRegistration处被调用，finishRegistration在onApplicationEvent()阶段被执行<br>
<img src="https://img-blog.csdnimg.cn/2020022217035698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
具体执行逻辑如下，注意两处判断逻辑，如果ScheduledAnnotationBeanPostProcessor实例的scheduler不为空就把它设置给ScheduledTaskRegistrar，否则进入下面加载逻。<br>
<img src="https://img-blog.csdnimg.cn/20200222171355130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>按照先类型、再名称顺序从容器中分别查找TaskScheduler、ScheduledExecutorService对象<br>
<img src="https://img-blog.csdnimg.cn/20200222171726611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>上述逻辑打断点发现默认通过this.registrar.setTaskScheduler(resolveSchedulerBean(this.beanFactory, TaskScheduler.class, false))方法加载到TaskScheduler实例，通过resolveNameBean得到一个NameBeanHolder实例，我们知道Spring 默认类别名为类名首字母小写，这里传入类型为TaskScheduler，holder.gerBeanName()为taskScheduler<br>
<img src="https://img-blog.csdnimg.cn/20200222172924489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
TaskScheduler的实现有如下三种<br>
<img src="https://img-blog.csdnimg.cn/20200222175259578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
通过debug发现加载的实例为ThreadPoolTaskScheduler类型<br>
<img src="https://img-blog.csdnimg.cn/20200222174926204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
到这里我们已经知道了***@Scheduled是如何被装载处理的*** 、 <strong>委托执行对象(定时器执行单元)是如何加载的</strong>以及***加载的对象是ThreadPoolTaskScheduler类型***，那为什么默认是这个类型呢？别忘了我们还有一个非常重要的注解@EnableScheduling，这个注解是定时任务的开关、并且会进行缺省配置。TaskSchedulingAutoConfiguration为自动配置类</p>
<p>从配置文件中加载默认配置构造TaskSchedulerBuilder对象并执行构建方法builder进行构建<br>
<img src="https://img-blog.csdnimg.cn/20200222184333203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>build()实现<br>
<img src="https://img-blog.csdnimg.cn/20200222184922770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
ThreadPoolTaskScheduler默认线程为1，内部依赖JDK ScheduledExecutorService实现<img src="https://img-blog.csdnimg.cn/20200222184956572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"> <img src="https://img-blog.csdnimg.cn/20200222185028735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
createExecutor()实现，可以看到创建了一个ScheduledExecutorService，默认poolSize为1<br>
<img src="https://img-blog.csdnimg.cn/2020022218542941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>由此分析与验证结果一致。<strong>@Scheduled注解默认采用单线程执行，执行单元是Spring 实现的ThreadPoolTaskScheduler封装了JDK JUC调度器ScheduledExecutorService实现。</strong></p>
<p>最后再往回翻代码发现，ScheduledAnnotationBeanPostProcessor#setScheduler(Object)方法的注释已经说的很清楚，如果不进行配置，默认实现为单线程。<br>
<img src="https://img-blog.csdnimg.cn/20200222190147831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>接下来就是解决问题了，请见下篇《Spring @Scheduled线程模型探究 - 解决问题》。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring @Scheduled线程模型探究 - 发现问题]]></title>
        <id>https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-fa-xian-wen-ti/</id>
        <link href="https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-fa-xian-wen-ti/">
        </link>
        <updated>2020-02-27T13:43:14.000Z</updated>
        <content type="html"><![CDATA[<p>最近工程中发现一个奇怪的问题，简单代码逻辑如下所示：</p>
<pre><code class="language-java">@EnableScheduling
@Component
public class SimpleImplement {
    private static final Logger LOG = LoggerFactory.getLogger(SimpleImplement.class);

    private volatile List&lt;String&gt; list = Collections.EMPTY_LIST;

    private final Queue&lt;Thread&gt; waiters = Queues.newConcurrentLinkedQueue();

    // 如果list为空挂起线程
    public List&lt;String&gt; get(){
        while(CollectionUtils.isEmpty(list)){
            try {
                Thread current = Thread.currentThread();
                waiters.add(current);
                LOG.info(&quot;list 为空挂起线程 {}.&quot;, current.getName());
                LockSupport.park();
            }catch (Exception e){}
        }
        return list;
    }

    // 异步更新list，如果list不为空则唤醒被挂起的线程
    @Scheduled(fixedDelay = 1000)
    private void sync(){
        // 加载数据
        list = ...;
        if(CollectionUtils.isNotEmpty(list)){
            Thread waiter = null;
            while (!waiters.isEmpty()){
                waiter = waiters.remove();
                LOG.info(&quot;同步数据 list 不为空唤醒线程 {}.&quot;, waiter.getName());
                LockSupport.unpark(waiter);
            }
        }
    }
</code></pre>
<p>上边代码对list异步加载，调用get接口的时候如果list为空就挂起当前线程，待有数据加载时再进行唤醒。我们知道加锁也可以实现等待唤醒，这里用LockSupport是因为这里是异步加载数据不存在数据竞争问题，加锁会让多个线程串行执行，影响任务执行效率。</p>
<p><em><strong>问题</strong></em><br>
get()接口在工程中好几处被调用，测试发现被挂起的线程有时会唤醒失败。反复测试几次从日志中看被阻塞的线程都是 scheduling-1，看起像是定时器的线程。于是翻看了代码发现几处调用get()接口的地方都采用@Scheduled注解进行周期轮询。</p>
<p><em><strong>分析</strong></em><br>
怀疑这里可能是@Scheduled的实现是单线程，几处定时任务都是有同一个线程执行，如果这样调用sync()接口的线程也是调用get()接口的线程，如果被阻塞那么唤醒动作就一直得不到执行。</p>
<p><em><strong>验证</strong></em><br>
为了验证我们的想法，写了个简单的测试代码及结果如下:</p>
<pre><code class="language-java">@Component
@EnableScheduling
public class ScheduledTest {
    private static Logger LOG = LoggerFactory.getLogger(ScheduledTest.class);

    @Scheduled(fixedDelay = 1000)
    public void method1(){
        LOG.info(&quot;线程 {} 执行method1 .&quot;, Thread.currentThread().getName());
    }

    @Scheduled(fixedDelay = 1000)
    public void method2(){
        LOG.info(&quot;线程 {} 执行method2 .&quot;, Thread.currentThread().getName());
    }
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020022214412263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
测试发现@Scheduled注解确实是单线程执行，执行method1和method2的线程都是scheduing-1，并且在打印完method1执行的log后5秒才打印method2的log，说明在这里scheduling-1在method1被阻塞了5秒。</p>
<p>这里刚好验证了我们的猜想：<strong>被挂起的线程没有被唤醒，是因为执行唤醒和被挂起的是同一个线程</strong>。</p>
<p>现在已经确定问题了，接下来就是怎么改。改之前去翻看下源码找到问题的根源，才能更好的解决问题，源码分析接下篇<a href="https://blog.csdn.net/zyc920716/article/details/104444109">《Spring @Scheduled线程模型探究 - 源码追踪》</a>。</p>
]]></content>
    </entry>
</feed>