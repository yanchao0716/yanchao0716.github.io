<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yanchao0716.github.io</id>
    <title>yanchao&apos; blog</title>
    <updated>2020-02-27T14:00:57.632Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yanchao0716.github.io"/>
    <link rel="self" href="https://yanchao0716.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://yanchao0716.github.io/images/avatar.png</logo>
    <icon>https://yanchao0716.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, yanchao&apos; blog</rights>
    <entry>
        <title type="html"><![CDATA[JDK源码走读之ArrayList]]></title>
        <id>https://yanchao0716.github.io/post/jdk-yuan-ma-zou-du-zhi-arraylist/</id>
        <link href="https://yanchao0716.github.io/post/jdk-yuan-ma-zou-du-zhi-arraylist/">
        </link>
        <updated>2020-02-27T14:00:39.000Z</updated>
        <content type="html"><![CDATA[<p>ArrayList其实就是动态数据，它封装了初始化、添加、删除、遍历等操作，并加入了泛型支持，下面我们从几个方面来分析一下ArrayList的实现。</p>
<h2 id="定义">定义</h2>
<pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
{
    private static final long serialVersionUID = 8683452581122892189L;
    private static final int DEFAULT_CAPACITY = 10;
    private static final Object[] EMPTY_ELEMENTDATA = {};
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    transient Object[] elementData; // non-private to simplify nested class access
    private int size;
	
    ….
}
</code></pre>
<h2 id="初始化">初始化</h2>
<p>初始化的时候可以指定数组大小，系统会按照指定大小初始化数组；如果不指定大小则默认为空数组。</p>
<pre><code>public ArrayList(int initialCapacity) {
        if (initialCapacity &gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        }
    }
    
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
</code></pre>
<h2 id="添加元素">添加元素</h2>
<p>1.调用add(E e)方法添加元素，默认会添加到数据的最后，添加元素之前首先要确保当前数组有空间能够接纳新元素，如果空间不够则进行扩容</p>
<pre><code>public boolean add(E e) {
    // 确保数组有足够的空间接纳新元素
        ensureCapacityInternal(size + 1);
        elementData[size++] = e;
        return true;
}

private void ensureCapacityInternal(int minCapacity) {
	if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
		minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
	}
	ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
	modCount++;
    // 如果数组长度不满足要求，则进行扩容，具体实现参考数据扩容
	if (minCapacity - elementData.length &gt; 0)
		grow(minCapacity); 
}
</code></pre>
<p>2.调用把元素添add(int index, E element)方法把元素加到指定位置，具体实现如下</p>
<pre><code>public void add(int index, E element) {
	rangeCheckForAdd(index);
	ensureCapacityInternal(size + 1);
// 调用native方法在数据中间插入元素
	System.arraycopy(elementData, index, elementData, index + 1,
					 size - index);
	elementData[index] = element;
	size++;
}
</code></pre>
<h2 id="数组扩容">数组扩容</h2>
<p>数组的最大长度为Integer.MAX_VALUE - 8 即2147483639，进行数据扩容时首先要确保新申请的数据长度不能超过该值，然后调用底层native方法开辟新数据，并把数据复制进去</p>
<pre><code>private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

private void grow(int minCapacity) {
	int oldCapacity = elementData.length;
	// 默认数组长度扩大为当前长度的1.5倍
	int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
	if (newCapacity - minCapacity &lt; 0)
		newCapacity = minCapacity;
	// 确保数组最大长度不超过MAX_ARRAY_SIZE
	if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
		newCapacity = hugeCapacity(minCapacity);
	// 开辟新数组，并把移动到新数组中。
	elementData = Arrays.copyOf(elementData, newCapacity);
}

private static int hugeCapacity(int minCapacity) {
	if (minCapacity &lt; 0) // overflow
		throw new OutOfMemoryError();
	// 如果申请长度超过上限
	return (minCapacity &gt; MAX_ARRAY_SIZE) ?
		Integer.MAX_VALUE :
		MAX_ARRAY_SIZE;
}

Arrays.copyOf(elementData, newCapacity)方法实现如下

public static &lt;T&gt; T[] copyOf(T[] original, int newLength) {
	return (T[]) copyOf(original, newLength, original.getClass());
}

public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {
    // 判断数组类型是否匹配，如果不匹配则调用native方法开辟新数组
	T[] copy = ((Object)newType == (Object)Object[].class)
		? (T[]) new Object[newLength]
		// native方法
		: (T[]) Array.newInstance(newType.getComponentType(), newLength);
	// native方法
	System.arraycopy(original, 0, copy, 0,
					 Math.min(original.length, newLength));
	return copy;
}
</code></pre>
<h2 id="删除元素">删除元素</h2>
<p>1.remove(int index)方法可以删除指定位置的元素，调用该方法会直接移除对应下边的元素，并对数据进行整理(调用System.arraycopy方法进行复制)，这样可以有效的减小对内存空间的占用，但是由于其需要整理内存，相对来说代价较大。</p>
<pre><code>public E remove(int index) {
	// 检查是否越界
	rangeCheck(index);

	modCount++;
	E oldValue = elementData(index);

	int numMoved = size - index - 1;
	if (numMoved &gt; 0)
		// 把删除元素【之前的部分】和【之后的部分】拼接
		System.arraycopy(elementData, index+1, elementData, index,
						 numMoved);
	// 释放引用，这样GC的时候就能被回收
	elementData[--size] = null; 

	return oldValue;
}
</code></pre>
<p>2.remove(Object o)移除数组中o元素，通过循环遍历定位到o元素，并进行移除。该方法没有直接进行内存整理，而是释放数据对元素的引用，这样在GC的时候就可以回收o元素，但是o对应的数据位置会被赋值为null，并不会被释放。</p>
<pre><code>public boolean remove(Object o) {
	// 循环超找元素，找到之后进行清理，并返回true
	if (o == null) {
		for (int index = 0; index &lt; size; index++)
			if (elementData[index] == null) {
				fastRemove(index);
				return true;
			}
	} else {
		for (int index = 0; index &lt; size; index++)
			if (o.equals(elementData[index])) {
				fastRemove(index);
				return true;
			}
	}
	return false;
}
</code></pre>
<h2 id="总结">总结</h2>
<ol>
<li>数据扩容需要调用底层重新开辟内存空间，并进行数据的移动，使用ArrayList在初始化的时候尽量指定合适的容量，以避免数据频繁扩容</li>
<li>数据的默认大小是10，每次扩容变为原来的1.5倍，即15、22、33.....</li>
<li>ArrayList查询较快，时间复杂度为O(1)，（指定位置）添加元素和（指定位置）删除元素较慢平均时间复杂度为O(n)</li>
<li>尽量避免频繁调用add(int index, E element)和remove(int index)方法，这两个方法会调用System.copy对内存进行整理，相对代价较大</li>
<li>ArrayList不是线程安全的，并发场景下可以使用vector替代</li>
</ol>
<p>注:以上源码为JDK1.8</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何优雅的停止服务（ShutdownHook）]]></title>
        <id>https://yanchao0716.github.io/post/ru-he-you-ya-de-ting-zhi-fu-wu-shutdownhook/</id>
        <link href="https://yanchao0716.github.io/post/ru-he-you-ya-de-ting-zhi-fu-wu-shutdownhook/">
        </link>
        <updated>2020-02-27T13:58:11.000Z</updated>
        <content type="html"><![CDATA[<p>JDK提供了Runtime.addShutdownHook(Thread hook)方法用来注册一个钩子(线程)，在Java程序退出时会调用这个钩子来清理现场。</p>
<p>这个钩子会在以下场景中被调用：</p>
<ol>
<li>程序正常退出</li>
<li>使用System.exit()</li>
<li>终端使用Ctrl+C触发的中断</li>
<li>系统关闭</li>
<li>OutOfMemory宕机</li>
<li>使用Kill pid命令干掉进程（注：在使用kill -9 pid时，是不会被调用的）</li>
</ol>
<p>下面我们来简单的模拟一个服务，详细说明如何优雅的终止Java进程。</p>
<pre><code>/**
 * zyc 2017年10月16日 下午3:05:03
 */
public class ShutdownHookTest{
	private static ExecutorService executorService = Executors.newFixedThreadPool(10);
	private static final long TIMEOUT = 10 * 1000;
	
	public static void main(String[] args) {
		
		// 注册钩子函数，在JVM接收到停止指令后会运行该线程
		Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;invoke shutdownhook ....&quot;);
				// 调用该方法把threadpool 的 shutdown 设置为true，不再接受提交任务，
				// 等待已经提交的任务执行完之后才会退出
				executorService.shutdown(); 
				long time = System.currentTimeMillis();
				while(true){
					int activeCount = ((ThreadPoolExecutor)executorService).getActiveCount(); // 执行中的线程数
					int waitCount = ((ThreadPoolExecutor)executorService).getQueue().size(); // 等待的线程数
					System.out.println(&quot;there are &quot; + waitCount + &quot; threads wait ....&quot;);
					System.out.println(&quot;there are &quot; + activeCount + &quot; threads working ....&quot;);
					if(executorService.isTerminated()){ // 等待线程池退出
						System.out.println(&quot;thread pool is shutdown ...&quot;);
						break;
					}
					if(System.currentTimeMillis() - time &gt; TIMEOUT) // 超时
						executorService.shutdownNow();
					sleep(500);
				}
			}
		}));
		
		// 模拟工作环境，不断往线程池提交任务
		for(;;){
			if(executorService.isShutdown())
				break;
			executorService.submit(new Runnable() {
				@Override
				public void run() {
					String name = Thread.currentThread().getName();
					System.out.println(name + &quot; work ....&quot;);
					sleep(2 * 1000); // 模拟线程工作
				}
			});
			sleep(500);
		}
	}
	
	
	private static void sleep(long millis){
		try {
			TimeUnit.MILLISECONDS.sleep(millis);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

</code></pre>
<p>把代码打成Jar包在linux上运行 java –jar ShutdownHookTest.jar，输出如下：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTUwNTUzODc3?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
线程池在持续工作，并不断的有任务提交。</p>
<p>执行kill命令终止Java进程<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTUwNjQ1MDU0?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
注意：这里用的是kill -15 pid 不是kill -9 pid</p>
<p>Java进程接收到终止指令后，调用钩子方法，直到线程池里的所有任务都执行完毕才退出<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDE2MTUwNzU4NzQ4?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<p>本文简单的模拟了关闭服务的场景，通过不断的轮询线程池的状态，直到所有提交的任务执行完毕才终止进程，清理的逻辑在钩子函数的run方法中实现即可，更多的功能请各位自己尝试。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 死锁分析]]></title>
        <id>https://yanchao0716.github.io/post/java-si-suo-fen-xi/</id>
        <link href="https://yanchao0716.github.io/post/java-si-suo-fen-xi/">
        </link>
        <updated>2020-02-27T13:56:23.000Z</updated>
        <content type="html"><![CDATA[<p>发生死锁需要满足4个条件：</p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p>下面代码模拟了死锁：</p>
<pre><code>package me.zyc.lock.test;

public class DeadLock{
	public static void methodA(){
		String thread_name = Thread.currentThread().getName();
		System.out.println(thread_name + &quot; acquiring lock on LockA.class&quot;);
		synchronized (LockA.class) {
			System.out.println(thread_name + &quot; locked on LockA.class&quot;);
			doSomething(); // wait other thread lock on LockB
			System.out.println(thread_name + &quot; acquiring lock on LockB.class&quot;);
			synchronized (LockB.class) {
				System.out.println(thread_name + &quot;locked on LockB.class&quot;);
				if(true) for(;;){}
			}
			System.out.println(thread_name + &quot; released lock on LockB.class&quot;);
		}
		System.out.println(thread_name + &quot; released lock on LockA.class&quot;);
	}
	
	public static void methodB(){
		String thread_name = Thread.currentThread().getName();
		System.out.println(thread_name + &quot; acquiring lock on LockB.class&quot;);
		synchronized (LockB.class) {
			System.out.println(thread_name + &quot; locked on LockB.class&quot;);
			doSomething();  // wait other thread lock on LockA
			System.out.println(thread_name + &quot; acquiring lock on LockA.class&quot;);
			synchronized (LockA.class) {
				System.out.println(thread_name + &quot; locked on LockA.class&quot;);
				if(true) for(;;){}
			}
			System.out.println(thread_name + &quot; released lock on LockA.class&quot;);
		}
		System.out.println(thread_name + &quot; released lock on LockB.class&quot;);
	}
	
	public static void doSomething(){
		try {
			Thread.sleep(300);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	} 
	
	public static void main(String[] args) {
		new Thread(new Runnable() {
			public void run() {
				DeadLock.methodA();
			}
		}).start();
		
		new Thread(new Runnable() {
			public void run() {
				DeadLock.methodB();
			}
		}).start();
	}
	private class LockA{}
	private class LockB{}
}

</code></pre>
<p>代码运行输出如下：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI4MTQwNzUzOTYx?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<ol>
<li>thread-0 获取了锁LockA，thread-1 获取了锁LockB。</li>
<li>thread-0 尝试获取LockB，但是由于thread-1一直占用LockB未释放，thread-0被阻塞。</li>
<li>thread-1尝试获取LockA，但是由于thread-0一直占用LockA未释放，thread-1被阻塞</li>
</ol>
<p>jstack是Java自带线程分析工具，用法如下：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI4MTQxNzAyMjYy?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<p>执行jstack -l pid，结果如下：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI4MTQxNzM5ODg2?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<ol>
<li>thread-0 和 thread-1均处于<strong>BLOCKED</strong>状态。</li>
<li>thread-0 获取了锁LockA，并等待获取LockB。</li>
<li>thread-1 获取了锁LockB，并等待获取LockjA。</li>
</ol>
<p>在最后jstack给出了更详细的死锁信息<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI4MTQyMzM1ODM2?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring @Scheduled线程模型探究 - 源码追踪]]></title>
        <id>https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-yuan-ma-zhui-zong/</id>
        <link href="https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-yuan-ma-zhui-zong/">
        </link>
        <updated>2020-02-27T13:49:15.000Z</updated>
        <content type="html"><![CDATA[<p>接<a href="https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-fa-xian-wen-ti/">上一篇</a>我们来分析一下 @Scheduled 这个定时器的注解实现</p>
<p>首先我看下@Scheduled注解的定义</p>
<pre><code class="language-java">package org.springframework.scheduling.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(Schedules.class)
public @interface Scheduled {
	String CRON_DISABLED = &quot;-&quot;;
	String cron() default &quot;&quot;;
	String zone() default &quot;&quot;;
	long fixedDelay() default -1;
	String fixedDelayString() default &quot;&quot;;
	long fixedRate() default -1;
	String fixedRateString() default &quot;&quot;;
	long initialDelay() default -1;
	String initialDelayString() default &quot;&quot;;
}
</code></pre>
<p>注解的字段分别对cron表达式、fixedDelay、fixRate进行了支持，可以传入value</p>
<p>紧接着我们看下@Scheduled在哪里被用到，跟进去查看一下实现<br>
<img src="https://img-blog.csdnimg.cn/20200222151601696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>这里我们主要看ScheduledAnnotationBeanPostProcessor这个类，其他几个类我们稍后再说。<br>
<img src="https://img-blog.csdnimg.cn/20200222154351658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>ScheduledAnnotationBeanPostProcessor是spring BeanPostProcessor的实现，postProcessAfterInitialization(Object bean, String beanName)方法在Bean初始化之后执行。</p>
<ol>
<li>提取定时方法：抽取@Scheduled注解以及被注解的方法</li>
<li>处理定时方法：对定时方法进行注册委托给定时器，通过processScheduled()方法实现</li>
</ol>
<p>processScheduled方法提取了注解上的值，cron、fixedDelay、fixRate分别包装成不同的对象，通过registrar.scheduleCronTask方法注册到registrar中</p>
<pre><code class="language-java">protected void processScheduled(Scheduled scheduled, Method method, Object bean) {
		 	Runnable runnable = createRunnable(bean, method);
			Set&lt;ScheduledTask&gt; tasks = new LinkedHashSet&lt;&gt;(4);
			
			// 确定定时器初始延迟时间
			long initialDelay = scheduled.initialDelay();
			String initialDelayString = scheduled.initialDelayString();
			...
			initialDelay = parseDelayAsLong(initialDelayString);
			...

			// cron表达式实现
			String cron = scheduled.cron();
			...
			tasks.add(this.registrar.scheduleCronTask(new CronTask(runnable, new CronTrigger(cron, timeZone))));
			...

			// fixed delay实现
			long fixedDelay = scheduled.fixedDelay();
			...
			tasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay)));
			...

			// fixed rate实现
			long fixedRate = scheduled.fixedRate();
			...
			tasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay)));
			...
		}
	}
</code></pre>
<p>registrar是ScheduledTaskRegistrar类的实例，ScheduledTaskRegistrar类主要结构如下</p>
<pre><code class="language-java">public class ScheduledTaskRegistrar implements ScheduledTaskHolder, InitializingBean, DisposableBean {
	private TaskScheduler taskScheduler;
	private ScheduledExecutorService localExecutor;
	private List&lt;TriggerTask&gt; triggerTasks;
	private List&lt;CronTask&gt; cronTasks;
	private List&lt;IntervalTask&gt; fixedRateTasks;
	private List&lt;IntervalTask&gt; fixedDelayTasks;
	private final Map&lt;Task, ScheduledTask&gt; unresolvedTasks = new HashMap&lt;&gt;(16);
	private final Set&lt;ScheduledTask&gt; scheduledTasks = new LinkedHashSet&lt;&gt;(16);
	
	public void setTaskScheduler(TaskScheduler taskScheduler){...}
	public void setScheduler(@Nullable Object scheduler) {...}
	
	public ScheduledTask scheduleCronTask(CronTask task) {...}
	public ScheduledTask scheduleFixedRateTask(FixedRateTask task) {...}
	public ScheduledTask scheduleFixedDelayTask(IntervalTask task) {...}
}
</code></pre>
<p>以cron为例注册逻辑实现如下，把包装的Runnable方法和Trigger交由taskScheduler处理<br>
<img src="https://img-blog.csdnimg.cn/20200222162128286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>再看下TaskScheduler这里是个接口，分别提供了三种模式的定义如下</p>
<pre><code class="language-java">public interface TaskScheduler {
	// ****** cron支持  ******
	ScheduledFuture&lt;?&gt; schedule(Runnable task, Trigger trigger);
	ScheduledFuture&lt;?&gt; schedule(Runnable task, Date startTime);

	// ****** FixedRate支持  ******
	ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable task, Date startTime, long period);
	ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable task, long period);
	
	// ****** FixedDelay支持  ******
	ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable task, Date startTime, long delay);
	ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable task, long delay);

}
</code></pre>
<p>看到这里我们就大概明白了，上面分析可以总结为    <em><strong>提取定时方法委托给taskScheduler执行</strong></em>。这个***taskScheduler的实现才是线程模型的关键***。又上边ScheduledTaskRegistrar类我们可以看到taskScheduler是通过setTaskScheduler、setScheduler方法传入的，我们只需要找到这俩方法在上面地方被调用即可。<br>
<img src="https://img-blog.csdnimg.cn/202002221657347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><img src="https://img-blog.csdnimg.cn/20200222165749476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>这俩方法都是在ScheduledAnnotationBeanPostProcessor#finishRegistration处被调用，finishRegistration在onApplicationEvent()阶段被执行<br>
<img src="https://img-blog.csdnimg.cn/2020022217035698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
具体执行逻辑如下，注意两处判断逻辑，如果ScheduledAnnotationBeanPostProcessor实例的scheduler不为空就把它设置给ScheduledTaskRegistrar，否则进入下面加载逻。<br>
<img src="https://img-blog.csdnimg.cn/20200222171355130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>按照先类型、再名称顺序从容器中分别查找TaskScheduler、ScheduledExecutorService对象<br>
<img src="https://img-blog.csdnimg.cn/20200222171726611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>上述逻辑打断点发现默认通过this.registrar.setTaskScheduler(resolveSchedulerBean(this.beanFactory, TaskScheduler.class, false))方法加载到TaskScheduler实例，通过resolveNameBean得到一个NameBeanHolder实例，我们知道Spring 默认类别名为类名首字母小写，这里传入类型为TaskScheduler，holder.gerBeanName()为taskScheduler<br>
<img src="https://img-blog.csdnimg.cn/20200222172924489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
TaskScheduler的实现有如下三种<br>
<img src="https://img-blog.csdnimg.cn/20200222175259578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
通过debug发现加载的实例为ThreadPoolTaskScheduler类型<br>
<img src="https://img-blog.csdnimg.cn/20200222174926204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
到这里我们已经知道了***@Scheduled是如何被装载处理的*** 、 <strong>委托执行对象(定时器执行单元)是如何加载的</strong>以及***加载的对象是ThreadPoolTaskScheduler类型***，那为什么默认是这个类型呢？别忘了我们还有一个非常重要的注解@EnableScheduling，这个注解是定时任务的开关、并且会进行缺省配置。TaskSchedulingAutoConfiguration为自动配置类</p>
<p>从配置文件中加载默认配置构造TaskSchedulerBuilder对象并执行构建方法builder进行构建<br>
<img src="https://img-blog.csdnimg.cn/20200222184333203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>build()实现<br>
<img src="https://img-blog.csdnimg.cn/20200222184922770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
ThreadPoolTaskScheduler默认线程为1，内部依赖JDK ScheduledExecutorService实现<img src="https://img-blog.csdnimg.cn/20200222184956572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"> <img src="https://img-blog.csdnimg.cn/20200222185028735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
createExecutor()实现，可以看到创建了一个ScheduledExecutorService，默认poolSize为1<br>
<img src="https://img-blog.csdnimg.cn/2020022218542941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>由此分析与验证结果一致。<strong>@Scheduled注解默认采用单线程执行，执行单元是Spring 实现的ThreadPoolTaskScheduler封装了JDK JUC调度器ScheduledExecutorService实现。</strong></p>
<p>最后再往回翻代码发现，ScheduledAnnotationBeanPostProcessor#setScheduler(Object)方法的注释已经说的很清楚，如果不进行配置，默认实现为单线程。<br>
<img src="https://img-blog.csdnimg.cn/20200222190147831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>接下来就是解决问题了，请见下篇《Spring @Scheduled线程模型探究 - 解决问题》。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring @Scheduled线程模型探究 - 发现问题]]></title>
        <id>https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-fa-xian-wen-ti/</id>
        <link href="https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-fa-xian-wen-ti/">
        </link>
        <updated>2020-02-27T13:43:14.000Z</updated>
        <content type="html"><![CDATA[<p>最近工程中发现一个奇怪的问题，简单代码逻辑如下所示：</p>
<pre><code class="language-java">@EnableScheduling
@Component
public class SimpleImplement {
    private static final Logger LOG = LoggerFactory.getLogger(SimpleImplement.class);

    private volatile List&lt;String&gt; list = Collections.EMPTY_LIST;

    private final Queue&lt;Thread&gt; waiters = Queues.newConcurrentLinkedQueue();

    // 如果list为空挂起线程
    public List&lt;String&gt; get(){
        while(CollectionUtils.isEmpty(list)){
            try {
                Thread current = Thread.currentThread();
                waiters.add(current);
                LOG.info(&quot;list 为空挂起线程 {}.&quot;, current.getName());
                LockSupport.park();
            }catch (Exception e){}
        }
        return list;
    }

    // 异步更新list，如果list不为空则唤醒被挂起的线程
    @Scheduled(fixedDelay = 1000)
    private void sync(){
        // 加载数据
        list = ...;
        if(CollectionUtils.isNotEmpty(list)){
            Thread waiter = null;
            while (!waiters.isEmpty()){
                waiter = waiters.remove();
                LOG.info(&quot;同步数据 list 不为空唤醒线程 {}.&quot;, waiter.getName());
                LockSupport.unpark(waiter);
            }
        }
    }
</code></pre>
<p>上边代码对list异步加载，调用get接口的时候如果list为空就挂起当前线程，待有数据加载时再进行唤醒。我们知道加锁也可以实现等待唤醒，这里用LockSupport是因为这里是异步加载数据不存在数据竞争问题，加锁会让多个线程串行执行，影响任务执行效率。</p>
<p><em><strong>问题</strong></em><br>
get()接口在工程中好几处被调用，测试发现被挂起的线程有时会唤醒失败。反复测试几次从日志中看被阻塞的线程都是 scheduling-1，看起像是定时器的线程。于是翻看了代码发现几处调用get()接口的地方都采用@Scheduled注解进行周期轮询。</p>
<p><em><strong>分析</strong></em><br>
怀疑这里可能是@Scheduled的实现是单线程，几处定时任务都是有同一个线程执行，如果这样调用sync()接口的线程也是调用get()接口的线程，如果被阻塞那么唤醒动作就一直得不到执行。</p>
<p><em><strong>验证</strong></em><br>
为了验证我们的想法，写了个简单的测试代码及结果如下:</p>
<pre><code class="language-java">@Component
@EnableScheduling
public class ScheduledTest {
    private static Logger LOG = LoggerFactory.getLogger(ScheduledTest.class);

    @Scheduled(fixedDelay = 1000)
    public void method1(){
        LOG.info(&quot;线程 {} 执行method1 .&quot;, Thread.currentThread().getName());
    }

    @Scheduled(fixedDelay = 1000)
    public void method2(){
        LOG.info(&quot;线程 {} 执行method2 .&quot;, Thread.currentThread().getName());
    }
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020022214412263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
测试发现@Scheduled注解确实是单线程执行，执行method1和method2的线程都是scheduing-1，并且在打印完method1执行的log后5秒才打印method2的log，说明在这里scheduling-1在method1被阻塞了5秒。</p>
<p>这里刚好验证了我们的猜想：<strong>被挂起的线程没有被唤醒，是因为执行唤醒和被挂起的是同一个线程</strong>。</p>
<p>现在已经确定问题了，接下来就是怎么改。改之前去翻看下源码找到问题的根源，才能更好的解决问题，源码分析接下篇<a href="https://blog.csdn.net/zyc920716/article/details/104444109">《Spring @Scheduled线程模型探究 - 源码追踪》</a>。</p>
]]></content>
    </entry>
</feed>