<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Java 死锁分析 | yanchao&#39; blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://yanchao0716.github.io/favicon.ico?v=1582813237032">
<link rel="stylesheet" href="https://yanchao0716.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="发生死锁需要满足4个条件：

互斥条件：一个资源每次只能被一个进程使用。
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
循环等待条件:若干进程之间形成一种..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://yanchao0716.github.io">
        <img src="https://yanchao0716.github.io/images/avatar.png?v=1582813237032" class="site-logo">
        <h1 class="site-title">yanchao&#39; blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://yanchao0716.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Java 死锁分析</h2>
            <div class="post-date">2020-02-27</div>
            
            <div class="post-content" v-pre>
              <p>发生死锁需要满足4个条件：</p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p>下面代码模拟了死锁：</p>
<pre><code>package me.zyc.lock.test;

public class DeadLock{
	public static void methodA(){
		String thread_name = Thread.currentThread().getName();
		System.out.println(thread_name + &quot; acquiring lock on LockA.class&quot;);
		synchronized (LockA.class) {
			System.out.println(thread_name + &quot; locked on LockA.class&quot;);
			doSomething(); // wait other thread lock on LockB
			System.out.println(thread_name + &quot; acquiring lock on LockB.class&quot;);
			synchronized (LockB.class) {
				System.out.println(thread_name + &quot;locked on LockB.class&quot;);
				if(true) for(;;){}
			}
			System.out.println(thread_name + &quot; released lock on LockB.class&quot;);
		}
		System.out.println(thread_name + &quot; released lock on LockA.class&quot;);
	}
	
	public static void methodB(){
		String thread_name = Thread.currentThread().getName();
		System.out.println(thread_name + &quot; acquiring lock on LockB.class&quot;);
		synchronized (LockB.class) {
			System.out.println(thread_name + &quot; locked on LockB.class&quot;);
			doSomething();  // wait other thread lock on LockA
			System.out.println(thread_name + &quot; acquiring lock on LockA.class&quot;);
			synchronized (LockA.class) {
				System.out.println(thread_name + &quot; locked on LockA.class&quot;);
				if(true) for(;;){}
			}
			System.out.println(thread_name + &quot; released lock on LockA.class&quot;);
		}
		System.out.println(thread_name + &quot; released lock on LockB.class&quot;);
	}
	
	public static void doSomething(){
		try {
			Thread.sleep(300);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	} 
	
	public static void main(String[] args) {
		new Thread(new Runnable() {
			public void run() {
				DeadLock.methodA();
			}
		}).start();
		
		new Thread(new Runnable() {
			public void run() {
				DeadLock.methodB();
			}
		}).start();
	}
	private class LockA{}
	private class LockB{}
}

</code></pre>
<p>代码运行输出如下：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI4MTQwNzUzOTYx?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<ol>
<li>thread-0 获取了锁LockA，thread-1 获取了锁LockB。</li>
<li>thread-0 尝试获取LockB，但是由于thread-1一直占用LockB未释放，thread-0被阻塞。</li>
<li>thread-1尝试获取LockA，但是由于thread-0一直占用LockA未释放，thread-1被阻塞</li>
</ol>
<p>jstack是Java自带线程分析工具，用法如下：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI4MTQxNzAyMjYy?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<p>执行jstack -l pid，结果如下：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI4MTQxNzM5ODg2?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>
<ol>
<li>thread-0 和 thread-1均处于<strong>BLOCKED</strong>状态。</li>
<li>thread-0 获取了锁LockA，并等待获取LockB。</li>
<li>thread-1 获取了锁LockB，并等待获取LockjA。</li>
</ol>
<p>在最后jstack给出了更详细的死锁信息<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI4MTQyMzM1ODM2?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"></p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://yanchao0716.github.io/post/spring-scheduled-xian-cheng-mo-xing-tan-jiu-yuan-ma-zhui-zong/">
                  <h3 class="post-title">
                    Spring @Scheduled线程模型探究 - 源码追踪
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
