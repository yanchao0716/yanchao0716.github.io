<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>JDK源码走读之ArrayList | yanchao&#39; blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://yanchao0716.github.io/favicon.ico?v=1583685778054">
<link rel="stylesheet" href="https://yanchao0716.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="ArrayList其实就是动态数据，它封装了初始化、添加、删除、遍历等操作，并加入了泛型支持，下面我们从几个方面来分析一下ArrayList的实现。
定义
public class ArrayList&lt;E&gt; extends Ab..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://yanchao0716.github.io">
        <img src="https://yanchao0716.github.io/images/avatar.png?v=1583685778054" class="site-logo">
        <h1 class="site-title">yanchao&#39; blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      总有一件值得让你付出热情
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://yanchao0716.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">JDK源码走读之ArrayList</h2>
            <div class="post-date">2020-02-27</div>
            
            <div class="post-content" v-pre>
              <p>ArrayList其实就是动态数据，它封装了初始化、添加、删除、遍历等操作，并加入了泛型支持，下面我们从几个方面来分析一下ArrayList的实现。</p>
<h2 id="定义">定义</h2>
<pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
{
    private static final long serialVersionUID = 8683452581122892189L;
    private static final int DEFAULT_CAPACITY = 10;
    private static final Object[] EMPTY_ELEMENTDATA = {};
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    transient Object[] elementData; // non-private to simplify nested class access
    private int size;
	
    ….
}
</code></pre>
<h2 id="初始化">初始化</h2>
<p>初始化的时候可以指定数组大小，系统会按照指定大小初始化数组；如果不指定大小则默认为空数组。</p>
<pre><code>public ArrayList(int initialCapacity) {
        if (initialCapacity &gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        }
    }
    
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
</code></pre>
<h2 id="添加元素">添加元素</h2>
<p>1.调用add(E e)方法添加元素，默认会添加到数据的最后，添加元素之前首先要确保当前数组有空间能够接纳新元素，如果空间不够则进行扩容</p>
<pre><code>public boolean add(E e) {
    // 确保数组有足够的空间接纳新元素
        ensureCapacityInternal(size + 1);
        elementData[size++] = e;
        return true;
}

private void ensureCapacityInternal(int minCapacity) {
	if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
		minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
	}
	ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
	modCount++;
    // 如果数组长度不满足要求，则进行扩容，具体实现参考数据扩容
	if (minCapacity - elementData.length &gt; 0)
		grow(minCapacity); 
}
</code></pre>
<p>2.调用把元素添add(int index, E element)方法把元素加到指定位置，具体实现如下</p>
<pre><code>public void add(int index, E element) {
	rangeCheckForAdd(index);
	ensureCapacityInternal(size + 1);
// 调用native方法在数据中间插入元素
	System.arraycopy(elementData, index, elementData, index + 1,
					 size - index);
	elementData[index] = element;
	size++;
}
</code></pre>
<h2 id="数组扩容">数组扩容</h2>
<p>数组的最大长度为Integer.MAX_VALUE - 8 即2147483639，进行数据扩容时首先要确保新申请的数据长度不能超过该值，然后调用底层native方法开辟新数据，并把数据复制进去</p>
<pre><code>private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

private void grow(int minCapacity) {
	int oldCapacity = elementData.length;
	// 默认数组长度扩大为当前长度的1.5倍
	int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
	if (newCapacity - minCapacity &lt; 0)
		newCapacity = minCapacity;
	// 确保数组最大长度不超过MAX_ARRAY_SIZE
	if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
		newCapacity = hugeCapacity(minCapacity);
	// 开辟新数组，并把移动到新数组中。
	elementData = Arrays.copyOf(elementData, newCapacity);
}

private static int hugeCapacity(int minCapacity) {
	if (minCapacity &lt; 0) // overflow
		throw new OutOfMemoryError();
	// 如果申请长度超过上限
	return (minCapacity &gt; MAX_ARRAY_SIZE) ?
		Integer.MAX_VALUE :
		MAX_ARRAY_SIZE;
}

Arrays.copyOf(elementData, newCapacity)方法实现如下

public static &lt;T&gt; T[] copyOf(T[] original, int newLength) {
	return (T[]) copyOf(original, newLength, original.getClass());
}

public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {
    // 判断数组类型是否匹配，如果不匹配则调用native方法开辟新数组
	T[] copy = ((Object)newType == (Object)Object[].class)
		? (T[]) new Object[newLength]
		// native方法
		: (T[]) Array.newInstance(newType.getComponentType(), newLength);
	// native方法
	System.arraycopy(original, 0, copy, 0,
					 Math.min(original.length, newLength));
	return copy;
}
</code></pre>
<h2 id="删除元素">删除元素</h2>
<p>1.remove(int index)方法可以删除指定位置的元素，调用该方法会直接移除对应下边的元素，并对数据进行整理(调用System.arraycopy方法进行复制)，这样可以有效的减小对内存空间的占用，但是由于其需要整理内存，相对来说代价较大。</p>
<pre><code>public E remove(int index) {
	// 检查是否越界
	rangeCheck(index);

	modCount++;
	E oldValue = elementData(index);

	int numMoved = size - index - 1;
	if (numMoved &gt; 0)
		// 把删除元素【之前的部分】和【之后的部分】拼接
		System.arraycopy(elementData, index+1, elementData, index,
						 numMoved);
	// 释放引用，这样GC的时候就能被回收
	elementData[--size] = null; 

	return oldValue;
}
</code></pre>
<p>2.remove(Object o)移除数组中o元素，通过循环遍历定位到o元素，并进行移除。该方法没有直接进行内存整理，而是释放数据对元素的引用，这样在GC的时候就可以回收o元素，但是o对应的数据位置会被赋值为null，并不会被释放。</p>
<pre><code>public boolean remove(Object o) {
	// 循环超找元素，找到之后进行清理，并返回true
	if (o == null) {
		for (int index = 0; index &lt; size; index++)
			if (elementData[index] == null) {
				fastRemove(index);
				return true;
			}
	} else {
		for (int index = 0; index &lt; size; index++)
			if (o.equals(elementData[index])) {
				fastRemove(index);
				return true;
			}
	}
	return false;
}
</code></pre>
<h2 id="总结">总结</h2>
<ol>
<li>数据扩容需要调用底层重新开辟内存空间，并进行数据的移动，使用ArrayList在初始化的时候尽量指定合适的容量，以避免数据频繁扩容</li>
<li>数据的默认大小是10，每次扩容变为原来的1.5倍，即15、22、33.....</li>
<li>ArrayList查询较快，时间复杂度为O(1)，（指定位置）添加元素和（指定位置）删除元素较慢平均时间复杂度为O(n)</li>
<li>尽量避免频繁调用add(int index, E element)和remove(int index)方法，这两个方法会调用System.copy对内存进行整理，相对代价较大</li>
<li>ArrayList不是线程安全的，并发场景下可以使用vector替代</li>
</ol>
<p>注:以上源码为JDK1.8</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://yanchao0716.github.io/post/ru-he-you-ya-de-ting-zhi-fu-wu-shutdownhook/">
                  <h3 class="post-title">
                    如何优雅的停止服务（ShutdownHook）
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
