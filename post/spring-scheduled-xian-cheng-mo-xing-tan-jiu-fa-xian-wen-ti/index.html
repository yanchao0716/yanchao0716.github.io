<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Spring @Scheduled线程模型探究 - 发现问题 | yanchao&#39; blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://yanchao0716.github.io/favicon.ico?v=1582811443158">
<link rel="stylesheet" href="https://yanchao0716.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="最近工程中发现一个奇怪的问题，简单代码逻辑如下所示：
@EnableScheduling
@Component
public class SimpleImplement {
    private static final Logger L..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://yanchao0716.github.io">
        <img src="https://yanchao0716.github.io/images/avatar.png?v=1582811443158" class="site-logo">
        <h1 class="site-title">yanchao&#39; blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://yanchao0716.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Spring @Scheduled线程模型探究 - 发现问题</h2>
            <div class="post-date">2020-02-27</div>
            
            <div class="post-content" v-pre>
              <p>最近工程中发现一个奇怪的问题，简单代码逻辑如下所示：</p>
<pre><code class="language-java">@EnableScheduling
@Component
public class SimpleImplement {
    private static final Logger LOG = LoggerFactory.getLogger(SimpleImplement.class);

    private volatile List&lt;String&gt; list = Collections.EMPTY_LIST;

    private final Queue&lt;Thread&gt; waiters = Queues.newConcurrentLinkedQueue();

    // 如果list为空挂起线程
    public List&lt;String&gt; get(){
        while(CollectionUtils.isEmpty(list)){
            try {
                Thread current = Thread.currentThread();
                waiters.add(current);
                LOG.info(&quot;list 为空挂起线程 {}.&quot;, current.getName());
                LockSupport.park();
            }catch (Exception e){}
        }
        return list;
    }

    // 异步更新list，如果list不为空则唤醒被挂起的线程
    @Scheduled(fixedDelay = 1000)
    private void sync(){
        // 加载数据
        list = ...;
        if(CollectionUtils.isNotEmpty(list)){
            Thread waiter = null;
            while (!waiters.isEmpty()){
                waiter = waiters.remove();
                LOG.info(&quot;同步数据 list 不为空唤醒线程 {}.&quot;, waiter.getName());
                LockSupport.unpark(waiter);
            }
        }
    }
</code></pre>
<p>上边代码对list异步加载，调用get接口的时候如果list为空就挂起当前线程，待有数据加载时再进行唤醒。我们知道加锁也可以实现等待唤醒，这里用LockSupport是因为这里是异步加载数据不存在数据竞争问题，加锁会让多个线程串行执行，影响任务执行效率。</p>
<p><em><strong>问题</strong></em><br>
get()接口在工程中好几处被调用，测试发现被挂起的线程有时会唤醒失败。反复测试几次从日志中看被阻塞的线程都是 scheduling-1，看起像是定时器的线程。于是翻看了代码发现几处调用get()接口的地方都采用@Scheduled注解进行周期轮询。</p>
<p><em><strong>分析</strong></em><br>
怀疑这里可能是@Scheduled的实现是单线程，几处定时任务都是有同一个线程执行，如果这样调用sync()接口的线程也是调用get()接口的线程，如果被阻塞那么唤醒动作就一直得不到执行。</p>
<p><em><strong>验证</strong></em><br>
为了验证我们的想法，写了个简单的测试代码及结果如下:</p>
<pre><code class="language-java">@Component
@EnableScheduling
public class ScheduledTest {
    private static Logger LOG = LoggerFactory.getLogger(ScheduledTest.class);

    @Scheduled(fixedDelay = 1000)
    public void method1(){
        LOG.info(&quot;线程 {} 执行method1 .&quot;, Thread.currentThread().getName());
    }

    @Scheduled(fixedDelay = 1000)
    public void method2(){
        LOG.info(&quot;线程 {} 执行method2 .&quot;, Thread.currentThread().getName());
    }
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020022214412263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzkyMDcxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
测试发现@Scheduled注解确实是单线程执行，执行method1和method2的线程都是scheduing-1，并且在打印完method1执行的log后5秒才打印method2的log，说明在这里scheduling-1在method1被阻塞了5秒。</p>
<p>这里刚好验证了我们的猜想：<strong>被挂起的线程没有被唤醒，是因为执行唤醒和被挂起的是同一个线程</strong>。</p>
<p>现在已经确定问题了，接下来就是怎么改。改之前去翻看下源码找到问题的根源，才能更好的解决问题，源码分析接下篇<a href="https://blog.csdn.net/zyc920716/article/details/104444109">《Spring @Scheduled线程模型探究 - 源码追踪》</a>。</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://yanchao0716.github.io/post/hello-gridea/">
                  <h3 class="post-title">
                    Hello Gridea
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
